# Masala
# Copyright (C) 2022 Vikram K. Mulligan
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

## @file code_templates/generate_library_api.py
## @brief Used during the build process to produce the auto-generated API layer code.
## @details Usage:
##          python3 generate_library_api.py <source library name> <json api definition file>
## @note The source library name is something like "core".  This Python code would then
## produce code in "core_api/auto_generated_api/".  This file should be run from the Masala
## root directory.
## @author Vikram K. Mulligan (vmulligan@flatironinstitute.org).

from dbm.ndbm import library
from genericpath import isdir
import json
from re import split as regex_split
from sys import argv
import os
import shutil

## @brief Parse the commandline options.
## @returns Source library name, JSON API definition file.  Throws if
## these two options aren't provided.
def get_options() -> tuple :
    assert len(argv) == 4, "Invalid commandline flags.  Expected usage: python3 generate_library_api.py <project name> <source library name> <json api definition file>"
    return (argv[1], argv[2], argv[3])

## @brief Returns true if a class starts with "masala::" or with project_name + "::".
## Always returns false if this is an API class.
def is_masala_class( project_name : str, classname : str ) -> bool :
    classname_split = classname.replace("::", " ").split()
    if len( classname_split ) > 2 and classname_split[1].endswith( "_api" ) :
        return False
    if classname.startswith( "masala::" ) : return True
    if classname.startswith( project_name + "::" ) : return True
    return False

## @brief Returns true if a class is a masala API class (i.e. follows pattern
## "masala::*_api::" ).
def is_masala_api_class( classname : str ) -> bool :
    if classname.startswith( "masala::" ) == False :
        return False
    classname_split = classname.split()[0].replace("::", " ").split()
    if len(classname_split) > 2 and classname_split[1].endswith("_api") :
        return True
    return False

## @brief Initialize the auto_generated_api directory, creating it if it does
## not exist and deleting anything in it if it does.
## @brief Puts a README.txt file in the directory indicating that it is auto-
## generated, and that no one should put anything in there manually.
def initialize_directory( library_name : str ) -> None :
    assert os.path.isdir( "src/" + library_name + "_api" ), "Error in generate_library_api.py: Could not find directory \"src/" + library_name + "\".  Note that this script must be run from the Masala root directory."
    apidir = "src/" + library_name + "_api/auto_generated_api/"
    if os.path.isdir( apidir ) :
        print( "\tFound directory \"" + apidir + "\".  Clearing contents." )
        shutil.rmtree( apidir )
    else :
        print( "\tCreating \"" + apidir + "\"." )
    os.makedirs( apidir )
    with open( apidir + "README.txt", 'w' ) as filehandle:
        filehandle.write( "Directory \"" + apidir + "\" is auto-generated by the build process.\n" )
        filehandle.write( "Do not put anything in this directory manually, since it is cleared and regenerated\n" )
        filehandle.write( "each time the build occurs.\n" )
    print( "\tWrote \"" + apidir + "README.txt.\"" )
    
## @brief Given a namespace for a class, create a directory in the auto-
## generated API directory with directory structure matching the
## namespace.  If the directory already exists, do nothing.
## @returns The directory name, for reuse later.
def prepare_directory( project_name : str, libname : str, namespace : list ) -> str :
    assert namespace[0] == project_name
    assert namespace[1] == libname
    dirname = "src/" + libname + "_api/auto_generated_api/"
    for i in range( 2, len(namespace) ) :
        dirname += namespace[i] + "/"
    if os.path.isdir( dirname ) == False :
        print( "\tCreating \"" + dirname + "\"." )
        os.makedirs( dirname )
    else :
        print( "\tDirectory \"" + dirname + "\" already exists.  Skipping creation." )
    return dirname

## @brief Given a namespace string of the form "XXXX::YYYY::ZZZZ", return a\
## list of [ "XXXX", "YYYY", "ZZZZ" ].
def separate_namespace( namespace_string ) -> list :
    return regex_split( "\:\:" , namespace_string )

## @brief Read a file and return its contents as a string.
def read_file( filename : str ) -> list :
    with open( filename, 'r' ) as filehandle :
        filecontents = filehandle.read()
    print( "\tRead contents of \"" + filename + "\" into memory." )
    return filecontents

## @brief Determine whether an object is an API type, and if so, access the
## class type inside.
def access_needed_object( project_name: str, classname : str, instancename : str, jsonfile : json ) -> str :
    if is_masala_class( project_name, classname ) == False :
        if classname.startswith( "MASALA_SHARED_POINTER" ) :
            firstchevron = classname.find( "<" )
            lastchevron = classname.rfind( ">" )
            innerclass = classname[firstchevron+1:lastchevron].strip()
            if is_masala_class( project_name, innerclass ) :
                return instancename + "->get_inner_object()"
        return instancename #Not an API class
    classtype = classname.split()[0]
    assert classtype in jsonfile["Elements"]
    if jsonfile["Elements"][classtype]["Properties"]["Is_Lightweight"]:
        return instancename + ".get_inner_object()"
    return "*( " + instancename + ".get_inner_object() )"

## @brief Given a Masala type that may contain "const", drop the const.
def drop_const( classname: str )-> str :
    classname_split = classname.split()
    outstr = ""
    first = True
    for entry in classname_split :
        if entry != "const" :
            if first == False :
                outstr += " "
            else :
                first = False
            outstr += entry
    return outstr

## @brief Add a Masala header to the list of additional headers to include.
def add_base_class_include( project_name : str, inputclass : str , additional_includes: list ) -> None :
    if is_masala_class( project_name, inputclass ) == False :
        # Do nothing.
        return
    includefile = inputclass[ inputclass.find("::") + 2 : ].replace( "::", "/" )
    if includefile not in additional_includes :
        additional_includes.append(includefile)

## @brief Given a class namespace and name, get a directory name.
def directory_and_name_from_namespace_and_name( namespace_and_name : str ) :
    namesplit = namespace_and_name.replace("::", " ").split()
    dirname = ""
    assert len(namesplit) > 2
    assert namesplit[0] == "masala"
    for i in range( 1, len(namesplit) - 1 ) :
        dirname += namesplit[i]
        if i < len(namesplit) - 2 :
            dirname += "/"
    return dirname, namesplit[len(namesplit) -1]

## @brief Given an enum class, find the forward header that defines it.
def find_enum_fwd_declarations( additional_includes : list, enum_namespace_and_name : str ) -> None :
    enum_directory, enum_name = directory_and_name_from_namespace_and_name( enum_namespace_and_name )

    print( "Searching for forward declaration that defines " + enum_name + " enum class in directory " + enum_directory + "." )
    found = False
    for filename in os.listdir( "src/" + enum_directory ) :
        if filename.endswith(".fwd.hh") == False :
            continue
        with open( "src/" + enum_directory + "/" + filename, 'r' ) as filehandle:
            filelines = filehandle.readlines()
        for line in filelines :
            if line.find( "enum" ) != -1 :
                linesplit = line.split()
                if len(linesplit) < 3 :
                    continue
                for i in range( len(linesplit)-2 ) :
                    if linesplit[i] == "enum" :
                        if linesplit[i+1] == "class" and linesplit[i+2] == enum_name :
                            found = True
                            fname_sans_end = enum_directory + "/" + filename[:-7]
                            if fname_sans_end not in additional_includes :
                                additional_includes.append(fname_sans_end)
                            break
    assert found == True, "Could not find file that defines enum class " + enum_name + "."

## @brief Given an API class, figure out the file to include.
## @note Return value does not include extension.
def include_file_from_masala_api_class( inputclass : str ) -> str :
    assert inputclass.startswith( "masala::" ), "Expected " + inputclass + " to start with masala::, but it did not!"
    inputclass_split = inputclass.split()[0].replace("::", " ").split()
    assert len(inputclass_split) > 1
    outfile = ""
    for i in range(1,len(inputclass_split)) :
        if i > 1 :
            outfile += "/"
        outfile += inputclass_split[i]
    return outfile

## @brief Given a class name, construct the name of the API class (if it is a Masala class)
## or do nothing (if it is not a Masala class.)
## @details Has certain exceptions, like masala::base::api::MasalaObjectAPIDefinition.
## @note As a side-effect, this populates the additional_includes list with files to include
## for the additional API classes.  Each entry added is first checked so that it is not added
## multiple times.  The extension (.hh or .fwd.hh) is omitted.
def correct_masala_types( project_name: str, inputclass : str, additional_includes: list, is_enum : bool = False ) -> str :
    #print( inputclass )
    if is_masala_class( project_name, inputclass ) == False :
        if inputclass.startswith( "MASALA_SHARED_POINTER" ) :
            firstchevron = inputclass.find( "<" )
            lastchevron = inputclass.rfind( ">" )
            return "MASALA_SHARED_POINTER< " + correct_masala_types( project_name, inputclass[firstchevron + 1 : lastchevron].strip(), additional_includes, is_enum=is_enum ) + " >"
        # elif inputclass.startswith( "std::MASALA_WEAK_POINTER" ) :
        #     firstchevron = inputclass.find( "<" )
        #     lastchevron = inputclass.rfind( ">" )
        #     return "std::MASALA_WEAK_POINTER< " + correct_masala_types( project_name, inputclass[firstchevron + 1 : lastchevron].strip(), additional_includes, is_enum=is_enum ) + " >"
        if is_masala_api_class( inputclass ) :
            additional_includes.append( include_file_from_masala_api_class( inputclass ) )
        return inputclass # Do nothing if ths isn't a masala class.
    
    api_classname = ""
    api_filename = ""
    firstspace = inputclass.find(" ")
    if firstspace == -1 :
        inputclass_base = inputclass
        inputclass_extension = ""
    else :
        inputclass_base = inputclass[0:firstspace]
        inputclass_extension = inputclass[firstspace + 1:]
    inputclass_split = inputclass_base.split("::")
    assert len(inputclass_split) > 2
    for i in range(len(inputclass_split)) :
        if i == 0 :
            continue # Skip "masala"
        curstring = inputclass_split[i]
        api_classname += curstring
        api_filename += curstring
        if i == 1 :
            if is_enum == False:
                api_classname += "_api::auto_generated_api"
                api_filename += "_api/auto_generated_api"
        if i == len(inputclass_split) - 1 :
            if is_enum == False :
                api_classname += "_API"
                api_filename += "_API"
        else :
            api_classname += "::"
            api_filename += "/"
    if is_enum == False and api_filename not in additional_includes :
        additional_includes.append( api_filename )
    if len(inputclass_extension) > 0 :
        return api_classname + " " + inputclass_extension
    return api_classname

    

## @brief Given the namespace as a list of strings, generate the C++ namespace lines.
## @details If opening_parentheses is true, we generate the parentheses that open the
## namespace.  Otherwise, we generate the parentheses that close the namespace.
def generate_cpp_namespace( namespace: list, opening_parentheses : bool ) -> str :
    outstr = ""
    for i in range( len(namespace) ) :
        if opening_parentheses == True :
            outstr += "namespace " + namespace[i]
            if i == 1 :
                outstr += "_api {\nnamespace auto_generated_api"
            outstr += " {"
        else :
            curindex = len(namespace) - i - 1
            outstr += "} // namespace " + namespace[curindex]
            if curindex == 1 :
                outstr += "_api\n} // namespace auto_generated_api"
        outstr += "\n"
    return outstr

## @brief Given the namespace as a list of strings, generate the C++ namespace for the API
## as a single line (separated by double colons):
def generate_cpp_namespace_singleline( namespace: list ) -> str :
    outstr = ""
    first = True
    for i in range( len( namespace ) ) :
        if first == True :
            first = False
        else :
            outstr += "::"
        outstr += namespace[i]
        if i == 1 :
            outstr += "_api::auto_generated_api"
    return outstr

## @brief Given a source class and namespace, generate the path and filename for a source file
## with a given extension.
def generate_source_class_filename( classname : str, namespace : list, extension : str ) -> str :
    assert len(namespace) >= 2
    outstr = ""
    for i in range( 1, len(namespace) ) :
        outstr += namespace[i]
        outstr += "/"
    outstr += classname + extension
    return outstr

## @brief Generate the prototypes for the constructors based on the JSON description of the API.
## @note The classname input should include namespace.
def generate_constructor_prototypes(project_name: str, classname: str, jsonfile: json, tabchar: str, additional_includes: list) -> str :
    outstring = ""
    first = True
    for constructor in jsonfile["Elements"][classname]["Constructors"]["Constructor_APIs"] :
        #print(constructor)
        if first :
            first = False
        else :
            outstring += "\n\n"
        outstring += tabchar + "/// @brief " + constructor["Constructor_Description"] + "\n"
        ninputs = constructor["Constructor_N_Inputs"]
        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += tabchar + "/// @param[in] " + constructor["Inputs"]["Input_" + str(i)]["Input_Name"] + " " + constructor["Inputs"]["Input_" + str(i)]["Input_Description"] + "\n"
        outstring += tabchar + constructor["Constructor_Name"] + "_API("
        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += "\n" + tabchar + tabchar + correct_masala_types( project_name, constructor["Inputs"]["Input_" + str(i)]["Input_Type"], additional_includes ) + " " + constructor["Inputs"]["Input_" + str(i)]["Input_Name"]
            outstring += "\n" + tabchar + ");"
        else :
            outstring += ");"
    return outstring

## @brief Generate the implementations for the constructors based on the JSON description of the API.
## @note The classname input should include namespace.
def generate_constructor_implementations(project_name: str, classname: str, jsonfile: json, tabchar: str, additional_includes: list, is_lightweight : bool, is_plugin_class : bool ) -> str :
    outstring = ""
    first = True

    if is_plugin_class == True :
        api_base_class = "masala::base::managers::plugin_module::MasalaPluginAPI"
    else :
        api_base_class = "masala::base::MasalaObjectAPI"

    for constructor in jsonfile["Elements"][classname]["Constructors"]["Constructor_APIs"] :
        #print(constructor)
        if first :
            first = False
        else :
            outstring += "\n\n"
        outstring += "/// @brief " + constructor["Constructor_Description"] + "\n"
        ninputs = constructor["Constructor_N_Inputs"]
        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += "/// @param[in] " + constructor["Inputs"]["Input_" + str(i)]["Input_Name"] + " " + constructor["Inputs"]["Input_" + str(i)]["Input_Description"] + "\n"
        outstring += constructor["Constructor_Name"] + "_API::" + constructor["Constructor_Name"] + "_API("
        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += "\n" + tabchar + correct_masala_types( project_name, constructor["Inputs"]["Input_" + str(i)]["Input_Type"], additional_includes ) + " " + constructor["Inputs"]["Input_" + str(i)]["Input_Name"]
            outstring += "\n" + ") :\n"
        else :
            outstring += ") :\n"
        
        # Initialization:
        outstring += tabchar + api_base_class + "(),\n"
        if is_lightweight == True :
            outstring += tabchar + "inner_object_("
        else:
            outstring += tabchar + "inner_object_( masala::make_shared< " + classname + " >("
        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += " " + access_needed_object( project_name, constructor["Inputs"]["Input_" + str(i)]["Input_Type"], constructor["Inputs"]["Input_" + str(i)]["Input_Name"], jsonfile )
                if i+1 < ninputs :
                    outstring += ","
                else :
                    outstring += " "
        
        if is_lightweight == True :
            outstring +=")\n"
        else :
            outstring +=") )\n"

        # Body:
        outstring += "{}"
    return outstring

## @brief Generate the prototypes for setters, getters, or work functions based on the JSON
## description of the API.
## @note The classname input should include namespace.  As a side-effect, this function appends to the
## additional_includes list.
def generate_function_prototypes( project_name: str, classname: str, jsonfile: json, tabchar: str, fxn_type: str, additional_includes: list) -> str :
    outstring = ""
    first = True

    assert fxn_type == "SETTER" or fxn_type == "GETTER" or fxn_type == "WORKFXN"
    if fxn_type == "SETTER" :
        groupname = "Setters"
        namepattern = "Setter"
    elif fxn_type == "GETTER" :
        groupname = "Getters"
        namepattern = "Getter"
    elif fxn_type == "WORKFXN" :
        groupname = "WorkFunctions"
        namepattern = "Work_Function"

    for fxn in jsonfile["Elements"][classname][groupname][namepattern+"_APIs"] :
        #print(fxn)
        if first :
            first = False
        else :
            outstring += "\n\n"
        outstring += tabchar + "/// @brief " + fxn[namepattern+"_Description"] + "\n"
        ninputs = fxn[namepattern+"_N_Inputs"]
        if ("Output" in fxn) and (fxn["Output"]["Output_Type"] != "void") :
            has_output = True
            if ("Output_Is_Enum" in fxn["Output"]) and (fxn["Output"]["Output_Is_Enum"] == True) :
                output_is_enum = True
                find_enum_fwd_declarations( additional_includes, fxn["Output"]["Output_Type"] )
            else :
                output_is_enum = False
        else :
            has_output = False

        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += tabchar + "/// @param[in] " + fxn["Inputs"]["Input_" + str(i)]["Input_Name"] + " " + fxn["Inputs"]["Input_" + str(i)]["Input_Description"] + "\n"
        if has_output :
            outstring += tabchar + "/// @returns " + fxn["Output"]["Output_Description"]
            if output_is_enum :
                outstring += "  (The return value is an enum.)\n"
            else :
                outstring += "\n"
            outstring += tabchar + correct_masala_types( project_name, fxn["Output"]["Output_Type"], additional_includes, is_enum=output_is_enum ) + "\n"
        else :
            outstring += tabchar + "void\n"
        outstring += tabchar + fxn[namepattern + "_Name"] + "("

        if fxn["Is_Const"] == True :
            conststr = " const"
        else :
            conststr = ""

        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += "\n" + tabchar + tabchar + correct_masala_types( project_name, fxn["Inputs"]["Input_" + str(i)]["Input_Type"], additional_includes ) + " " + fxn["Inputs"]["Input_" + str(i)]["Input_Name"]
            outstring += "\n" + tabchar + ")" + conststr + ";"
        else :
            outstring += ")" + conststr + ";"
    return outstring

## @brief Generate the implementations for setters, getters, or work functions based on the JSON
## description of the API.
## @note The classname input should include namespace.  As a side-effect, this function appends to the
## additional_includes list.
def generate_function_implementations( project_name: str, classname: str, jsonfile: json, tabchar: str, fxn_type: str, additional_includes: list, is_lightweight: bool ) -> str :
    outstring = ""
    first = True

    assert fxn_type == "SETTER" or fxn_type == "GETTER" or fxn_type == "WORKFXN"
    if fxn_type == "SETTER" :
        groupname = "Setters"
        namepattern = "Setter"
    elif fxn_type == "GETTER" :
        groupname = "Getters"
        namepattern = "Getter"
    elif fxn_type == "WORKFXN" :
        groupname = "WorkFunctions"
        namepattern = "Work_Function"

    apiclassname = jsonfile["Elements"][classname]["Module"] + "_API"

    for fxn in jsonfile["Elements"][classname][groupname][namepattern+"_APIs"] :
        #print(fxn)
        if first :
            first = False
        else :
            outstring += "\n\n"
        outstring += "/// @brief " + fxn[namepattern+"_Description"] + "\n"
        ninputs = fxn[namepattern+"_N_Inputs"]
        if ("Output" in fxn) :
            outtype = fxn["Output"]["Output_Type"]
            if outtype != "void" :
                has_output = True
            else :
                has_output = False
        else :
            outtype = "void"
            has_output = False

        outtype_base = outtype.split()[0]
        output_is_lightweight = False
        output_is_enum = False
        if is_masala_class( project_name, outtype_base )  :
            if fxn_type == "GETTER" and fxn["Output"]["Output_Is_Enum"] == True :
                output_is_enum = True
            else:
                assert outtype_base in jsonfile["Elements"], "ERROR: " + outtype_base + " not found in JSON Elements."
                if jsonfile["Elements"][outtype_base]["Properties"]["Is_Lightweight"] == True :
                    output_is_lightweight = True

        if ( "Returns_This_Ref" in fxn ) and ( fxn["Returns_This_Ref"] == True ) :
            returns_this_ref = True
        else :
            returns_this_ref = False

        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += "/// @param[in] " + fxn["Inputs"]["Input_" + str(i)]["Input_Name"] + " " + fxn["Inputs"]["Input_" + str(i)]["Input_Description"] + "\n"
        if has_output :
            outstring += "/// @returns " + fxn["Output"]["Output_Description"]
            if output_is_enum :
                outstring += "/// (The return value is an enum.)\n"
            else :
                outstring += "\n"
            outstring += correct_masala_types( project_name, outtype, additional_includes, is_enum=output_is_enum ) + "\n"
        else :
            outstring += "void\n"
        outstring +=  apiclassname + "::" + fxn[namepattern + "_Name"] + "("

        if fxn["Is_Const"] == True :
            conststr = " const"
        else :
            conststr = ""

        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += "\n" + tabchar + tabchar + correct_masala_types( project_name, fxn["Inputs"]["Input_" + str(i)]["Input_Type"], additional_includes ) + " " + fxn["Inputs"]["Input_" + str(i)]["Input_Name"]
            outstring += "\n)" + conststr + " {\n"
        else :
            outstring += ")" + conststr + " {\n"

        # Body:

        ismasalaAPIptr = False
        ismasalaAPIobj = False
        if outtype.startswith( "MASALA_SHARED_POINTER" ) :
            firstchevron = outtype.find("<")
            lastchevron = outtype.rfind(">")
            outtype_inner = outtype[firstchevron+1:lastchevron].strip()
            if( is_masala_class( project_name, outtype_inner )  ) :
                ismasalaAPIptr = True
        elif is_masala_class( project_name, outtype )  and returns_this_ref == False and output_is_enum == False :
            ismasalaAPIobj = True

        outstring += tabchar + "std::lock_guard< std::mutex > lock( api_mutex_ );\n"
        if (fxn_type == "GETTER" or fxn_type == "WORKFXN") and has_output == True and returns_this_ref == False :
            if ismasalaAPIptr :
                outstring += tabchar + "// On the following line, note that std::const_pointer_cast is safe to use.  We\n"
                outstring += tabchar + "// cast away the constness of the object, but effectively restore it by encapsulating\n"
                outstring += tabchar + "// it in an API object that only allows const access.  This is ONLY allowed in Masala\n"
                outstring += tabchar + "// code that is auto-generated in a manner that ensures that nothing unsafe is done\n"
                outstring += tabchar + "// with the nonconst object.\n"
            outstring += tabchar + "return "

            if ismasalaAPIptr and returns_this_ref == False :
                dummy = []
                outstring += "masala::make_shared< " + correct_masala_types( project_name, outtype_inner, dummy ) + " >(\n"
                outstring += tabchar + tabchar + "std::const_pointer_cast< " + drop_const( outtype_inner ) + " >(\n"
                outstring += tabchar + tabchar + tabchar
            elif ismasalaAPIobj :
                dummy = []
                outstring += correct_masala_types( project_name, outtype, dummy ) + "(\n"
                if output_is_lightweight :
                    outstring += tabchar + tabchar + outtype + "( "
                else :
                    outstring += tabchar + tabchar + "masala::make_shared< " + outtype + " >( "
                add_base_class_include( project_name, outtype, additional_includes )
        else :
            outstring += tabchar

        accessor_string = "->"
        if is_lightweight == True :
            accessor_string = "."
        outstring += "inner_object_" + accessor_string + fxn[namepattern + "_Name"] + "("
        if ninputs > 0 :
            for i in range(ninputs) :
                if is_masala_class( project_name, fxn["Inputs"]["Input_" + str(i)]["Input_Type"] ) :
                    inputtype = fxn["Inputs"]["Input_" + str(i)]["Input_Type"].split()[0] 
                    assert inputtype in jsonfile["Elements"], "Could not find " + inputtype + " in JSON file."
                    if jsonfile["Elements"][inputtype]["Properties"]["Is_Lightweight"] == True :
                        outstring += fxn["Inputs"]["Input_" + str(i)]["Input_Name"] + ".get_inner_object()"
                    else :
                        outstring += " *( " + fxn["Inputs"]["Input_" + str(i)]["Input_Name"] + ".get_inner_object() )"
                else:
                    outstring += " " + fxn["Inputs"]["Input_" + str(i)]["Input_Name"]
                if i+1 < ninputs :
                    outstring += ","
                else :
                    outstring += " "
        outstring += ")"
        if ismasalaAPIptr and returns_this_ref == False :
            outstring += "\n" + tabchar + tabchar + ")\n" + tabchar + ")"
        elif ismasalaAPIobj and returns_this_ref == False :
            outstring += " )\n" + tabchar + ")"
        outstring += ";\n"
        if returns_this_ref == True :
            outstring += tabchar + "return *this;\n"
        outstring += "}"
    return outstring

## @brief Given a list of additional files to include, generate a
## string of the inclusions.
def generate_additional_includes( additional_includes : list, generate_fwd_includes : bool, original_api_include: str ) -> str :
    outstr = ""
    if generate_fwd_includes == True :
        fwdstr = ".fwd"
    else :
        fwdstr = ""
    first = True
    for entry in additional_includes :
        if entry != original_api_include :
            if first == True :
                first = False
            else :
                outstr += "\n"
            outstr += "#include <" + entry + fwdstr + ".hh>"
    return outstr

## @brief Generate the categories for a plugin class, from the JSON description.
def generate_plugin_categories( \
    name_string : str, \
    namespace_string : str, \
    json_api : json
    ) -> str :

    outstr = ""
    categories = json_api["Elements"][ namespace_string + "::" + name_string ]["Plugin_Categories"]
    firstcat = True
    for category in categories :
        if firstcat == True :
            firstcat = False
        else :
            outstr += ", "
        outstr += "{ "
        first = True
        for entry in category :
            if first == True :
                first = False
            else :
                outstr += ", "
            outstr += "\"" + entry + "\""
        outstr += " }"
    return outstr

## @brief Generate the keywords for a plugin class, from the JSON description.
def generate_plugin_keywords( \
    name_string : str, \
    namespace_string : str, \
    json_api : json
    ) -> str :

    outstr = ""
    keywords = json_api["Elements"][ namespace_string + "::" + name_string ]["Plugin_Keywords"]
    first = True
    for entry in keywords :
        if first == True :
            first = False
        else :
            outstr += ", "
        outstr += "\"" + entry + "\""
    return outstr

## @brief Auto-generate the forward declaration file (***Creator.fwd.hh) for the creator for a plugin class.
def prepare_creator_forward_declarations( \
    plugin_creator_fwdfile_template : str, \
    licence : str, \
    creator_name : str, \
    creator_namespace : list, \
    creator_filename : str, \
    json_api : json, \
    name_string : str, \
    namespace : list, \
    library_name : str, \
    project_name : str \
    ) -> None :

    original_class_namespace_string = ""

    header_guard_string = capitalize_project_name(project_name) + "_" + library_name + "_api_auto_generated_api_"
    for i in range( len(namespace) ):
        original_class_namespace_string += namespace[i]
        if i+1<len(namespace) :
            original_class_namespace_string += "::"
        if i > 1 :
            header_guard_string += namespace[i] + "_"
    header_guard_string += creator_name + "_fwd_hh"

    plugin_creator_fwdfile = \
        plugin_creator_fwdfile_template \
        .replace( "<__COMMENTED_LICENCE__>", "/*\n" + licence + "\n*/\n" ) \
        .replace( "<__DOXYGEN_CREATOR_FILE_PATH_AND_FWD_FILE_NAME__>", "/// @file " + creator_filename[4:] + ".fwd.hh" ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE_AND_NAME__>", original_class_namespace_string + "::" + name_string ) \
        .replace( "<__DOXYGEN_AUTHOR_AND_EMAIL__>", "/// @author None (auto-generated by script code_templates/generate_library_api.py)." ) \
        .replace( "<__CPP_CREATOR_FWD_HEADER_GUARD__>", "#ifndef " + header_guard_string + "\n#define " + header_guard_string ) \
        .replace( "<__CPP_NAMESPACE__>", generate_cpp_namespace( namespace, True ) ) \
        .replace( "<__CPP_END_NAMESPACE__>", generate_cpp_namespace( namespace, False ) ) \
        .replace( "<__CREATOR_CLASS_API_NAME__>", creator_name ) \
        .replace( "<__CPP_END_FWD_HEADER_GUARD__>", "#endif //" + header_guard_string )

    with open( creator_filename + ".fwd.hh", 'w' ) as filehandle :
        filehandle.write( plugin_creator_fwdfile )
    print( "\tWrote \"" + creator_filename + ".fwd.hh\"." )

## @brief Auto-generate the header file (***Creator.hh) for the creator for a plugin class.
def prepare_creator_header_file( \
    plugin_creator_hhfile_template : str, \
    licence_template : str, \
    creator_name : str, \
    creator_namespace : list, \
    creator_filename : str, \
    json_api : json, \
    name_string : str, \
    namespace : list, \
    library_name : str, \
    project_name : str \
    ) -> None :

    original_class_namespace_string = ""
    creator_namespace_string = ""

    header_guard_string = capitalize_project_name(project_name) + "_" + library_name + "_api_auto_generated_api_"
    for i in range( len(namespace) ):
        original_class_namespace_string += namespace[i]
        if i+1<len(namespace) :
            original_class_namespace_string += "::"
        if i > 1 :
            header_guard_string += namespace[i] + "_"
    header_guard_string += creator_name + "_hh"

    first = True
    for entry in creator_namespace :
        if first == True :
            first = False
        else :
            creator_namespace_string += "::"
        creator_namespace_string += entry

    plugin_creator_hhfile = \
        plugin_creator_hhfile_template \
        .replace( "<__COMMENTED_LICENCE__>", "/*\n" + licence_template + "\n*/\n" ) \
        .replace( "<__DOXYGEN_CREATOR_FILE_PATH_AND_HH_FILE_NAME__>", "/// @file " + creator_filename[4:] + ".hh" ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE_AND_NAME__>", original_class_namespace_string + "::" + name_string ) \
        .replace( "<__DOXYGEN_AUTHOR_AND_EMAIL__>", "/// @author None (auto-generated by script code_templates/generate_library_api.py)." ) \
        .replace( "<__CPP_CREATOR_HH_HEADER_GUARD__>", "#ifndef " + header_guard_string + "\n#define " + header_guard_string ) \
        .replace( "<__CREATOR_INCLUDE_FILE_PATH_AND_FWD_FILE_NAME__>", "#include <" + creator_filename[4:] + ".fwd.hh>  " ) \
        .replace( "<__PLUGIN_CATEGORIES__>", generate_plugin_categories( name_string, original_class_namespace_string, json_api ) ) \
        .replace( "<__PLUGIN_KEYWORDS__>", generate_plugin_keywords( name_string, original_class_namespace_string, json_api ) ) \
        .replace( "<__CPP_NAMESPACE__>", generate_cpp_namespace( namespace, True ) ) \
        .replace( "<__CPP_END_NAMESPACE__>", generate_cpp_namespace( namespace, False ) ) \
        .replace( "<__SOURCE_CLASS_NAME__>", name_string ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE__>", original_class_namespace_string ) \
        .replace( "<__CREATOR_CLASS_API_NAME__>", creator_name ) \
        .replace( "<__CREATOR_CLASS_API_NAMESPACE__>", creator_namespace_string ) \
        .replace( "<__CPP_END_HH_HEADER_GUARD__>", "#endif //" + header_guard_string )

    with open( creator_filename + ".hh", 'w' ) as filehandle :
        filehandle.write( plugin_creator_hhfile )
    print( "\tWrote \"" + creator_filename + ".hh\"." )

## @brief Auto-generate the cc file (***Creator.cc) for the creator for a plugin class.
def prepare_creator_cc_file( \
    plugin_creator_ccfile_template : str, \
    licence_template : str, \
    creator_name : str, \
    creator_namespace : list, \
    creator_filename : str, \
    json_api : json, \
    name_string : str, \
    namespace : list, \
    library_name : str, \
    project_name : str, \
    api_dirname : str, \
    ) -> None :

    original_class_namespace_string = ""
    creator_namespace_string = ""
    api_dirname_short = api_dirname[4:]

    for i in range( len(namespace) ):
        original_class_namespace_string += namespace[i]
        if i+1<len(namespace) :
            original_class_namespace_string += "::"

    first = True
    for entry in creator_namespace :
        if first == True :
            first = False
        else :
            creator_namespace_string += "::"
        creator_namespace_string += entry

    plugin_creator_ccfile = \
        plugin_creator_ccfile_template \
        .replace( "<__COMMENTED_LICENCE__>", "/*\n" + licence_template + "\n*/\n" ) \
        .replace( "<__DOXYGEN_CREATOR_FILE_PATH_AND_CC_FILE_NAME__>", "/// @file " + creator_filename[4:] + ".cc" ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE_AND_NAME__>", original_class_namespace_string + "::" + name_string ) \
        .replace( "<__DOXYGEN_AUTHOR_AND_EMAIL__>", "/// @author None (auto-generated by script code_templates/generate_library_api.py)." ) \
        .replace( "<__CREATOR_INCLUDE_FILE_PATH_AND_HH_FILE_NAME__>", "#include <" + creator_filename[4:] + ".hh>  " ) \
        .replace( "<__PLUGIN_CATEGORIES__>", generate_plugin_categories( name_string, original_class_namespace_string, json_api ) ) \
        .replace( "<__PLUGIN_KEYWORDS__>", generate_plugin_keywords( name_string, original_class_namespace_string, json_api ) ) \
        .replace( "<__CPP_NAMESPACE__>", generate_cpp_namespace( namespace, True ) ) \
        .replace( "<__CPP_END_NAMESPACE__>", generate_cpp_namespace( namespace, False ) ) \
        .replace( "<__SOURCE_CLASS_NAME__>", name_string ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE__>", original_class_namespace_string ) \
        .replace( "<__CREATOR_CLASS_API_NAME__>", creator_name ) \
        .replace( "<__CREATOR_CLASS_API_NAMESPACE__>", creator_namespace_string ) \
        .replace( "<__API_INCLUDE_FILE_PATH_AND_HH_FILE_NAME__>", "#include <" + api_dirname_short + name_string + "_API.hh>" ) \
        .replace( "<__SOURCE_CLASS_API_NAME__>", name_string + "_API" )

    with open( creator_filename + ".cc", 'w' ) as filehandle :
        filehandle.write( plugin_creator_ccfile )
    print( "\tWrote \"" + creator_filename + ".cc\"." )
    
## @brief Auto-generate the forward declaration file (***.fwd.hh) for the class.
def prepare_forward_declarations( libraryname : str, classname : str, namespace : list, dirname : str, fwdfile_template : str, licence : str ) :
    apiclassname = classname + "_API"
    original_class_namespace_string = ""
    header_guard_string = capitalize_project_name(project_name) + "_" + libraryname + "_api_auto_generated_api_"
    for i in range( len(namespace) ):
        original_class_namespace_string += namespace[i]
        if i+1<len(namespace) :
            original_class_namespace_string += "::"
        if i > 1 :
            header_guard_string += namespace[i] + "_"
    header_guard_string += apiclassname + "_fwd_hh"

    dirname_short = dirname.replace("src/", "")
    namespace_and_source_class = original_class_namespace_string + "::" + classname

    fwdfile = \
        fwdfile_template \
        .replace( "<__COMMENTED_LICENCE__>", "/*\n" + licence + "\n*/\n" ) \
        .replace( "<__DOXYGEN_FILE_PATH_AND_FWD_FILE_NAME__>", "/// @file " + dirname_short + apiclassname + ".fwd.hh" ) \
        .replace( "<__DOXYGEN_FWD_BRIEF_DESCRIPTION__>", "/// @brief Forward declarations for auto-generated API for\n/// " + namespace_and_source_class + " class." ) \
        .replace( "<__DOXYGEN_DETAILED_DESCRIPTION__>", "/// @details This file was generated automatically.  Do not edit it, for changes\n/// will be lost on next rebuild." ) \
        .replace( "<__DOXYGEN_AUTHOR_AND_EMAIL__>", "/// @author None (auto-generated by script code_templates/generate_library_api.py)." ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE_AND_NAME__>", namespace_and_source_class ) \
        .replace( "<__CPP_FWD_HEADER_GUARD__>", "#ifndef " + header_guard_string + "\n#define " + header_guard_string ) \
        .replace( "<__CPP_NAMESPACE__>", generate_cpp_namespace( namespace, True ) ) \
        .replace( "<__CPP_END_NAMESPACE__>", generate_cpp_namespace( namespace, False ) ) \
        .replace( "<__SOURCE_CLASS_API_NAME__>", apiclassname ) \
        .replace( "<__CPP_END_FWD_HEADER_GUARD__>", "#endif // " + header_guard_string )

    fname = dirname + apiclassname + ".fwd.hh"
    with open( fname, 'w' ) as filehandle :
        filehandle.write(fwdfile)
    print( "\tWrote \"" + fname + "\"."  )

## @brief Auto-generate the header file (***.hh) for the class.
def prepare_header_file( project_name: str, libraryname : str, classname : str, namespace : list, dirname : str, hhfile_template : str, licence : str, jsonfile : json, tabchar : str, is_plugin_class : bool ) :
    apiclassname = classname + "_API"
    original_class_namespace_string = ""
    header_guard_string = capitalize_project_name(project_name) + "_" + libraryname + "_api_auto_generated_api_"
    for i in range( len(namespace) ):
        original_class_namespace_string += namespace[i]
        if i+1<len(namespace) :
            original_class_namespace_string += "::"
        if i > 1 :
            header_guard_string += namespace[i] + "_"
    header_guard_string += apiclassname + "_hh"

    if is_plugin_class == True :
        api_base_class_include = "#include <base/managers/plugin_module/MasalaPluginAPI.hh>"
        api_base_class = "masala::base::managers::plugin_module::MasalaPluginAPI"
    else :
        api_base_class_include = "#include <base/MasalaObjectAPI.hh>"
        api_base_class = "masala::base::MasalaObjectAPI"

    dirname_short = dirname.replace("src/", "")
    namespace_and_source_class = original_class_namespace_string + "::" + classname

    additional_includes = []

    hhfile = \
        hhfile_template \
        .replace( "<__COMMENTED_LICENCE__>", "/*\n" + licence + "\n*/\n" ) \
        .replace( "<__DOXYGEN_FILE_PATH_AND_HH_FILE_NAME__>", "/// @file " + dirname_short + apiclassname + ".hh" ) \
        .replace( "<__DOXYGEN_BRIEF_DESCRIPTION__>", "/// @brief Headers for auto-generated API for\n/// " + namespace_and_source_class + " class." ) \
        .replace( "<__DOXYGEN_DETAILED_DESCRIPTION__>", "/// @details This file was generated automatically.  Do not edit it, for changes\n/// will be lost on next rebuild." ) \
        .replace( "<__DOXYGEN_AUTHOR_AND_EMAIL__>", "/// @author None (auto-generated by script code_templates/generate_library_api.py)." ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE_AND_NAME__>", namespace_and_source_class ) \
        .replace( "<__SOURCE_CLASS_NAME__>", classname ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE__>", original_class_namespace_string ) \
        .replace( "<__CPP_HH_HEADER_GUARD__>", "#ifndef " + header_guard_string + "\n#define " + header_guard_string ) \
        .replace( "<__CPP_NAMESPACE__>", generate_cpp_namespace( namespace, True ) ) \
        .replace( "<__CPP_END_NAMESPACE__>", generate_cpp_namespace( namespace, False ) ) \
        .replace( "<__SOURCE_CLASS_API_NAME__>", apiclassname ) \
        .replace( "<__SOURCE_CLASS_API_NAMESPACE__>", generate_cpp_namespace_singleline( namespace ) ) \
        .replace( "<__INCLUDE_FILE_PATH_AND_FWD_FILE_NAME__>", "#include <" + dirname_short + apiclassname + ".fwd.hh>" ) \
        .replace( "<__INCLUDE_SOURCE_FILE_PATH_AND_FWD_FILE_NAME__>", "#include <" + generate_source_class_filename( classname, namespace, ".fwd.hh" ) + ">" ) \
        .replace( "<__INCLUDE_SOURCE_FILE_PATH_AND_HH_FILE_NAME__>", "#include <" + generate_source_class_filename( classname, namespace, ".hh" ) + ">" ) \
        .replace( "<__CPP_CONSTRUCTOR_PROTOTYPES__>", generate_constructor_prototypes(project_name, namespace_and_source_class, jsonfile, tabchar, additional_includes) ) \
        .replace( "<__CPP_SETTER_PROTOTYPES__>", generate_function_prototypes(project_name, namespace_and_source_class, jsonfile, tabchar, "SETTER", additional_includes) ) \
        .replace( "<__CPP_GETTER_PROTOTYPES__>", generate_function_prototypes(project_name, namespace_and_source_class, jsonfile, tabchar, "GETTER", additional_includes) ) \
        .replace( "<__CPP_WORK_FUNCTION_PROTOTYPES__>", generate_function_prototypes(project_name, namespace_and_source_class, jsonfile, tabchar, "WORKFXN", additional_includes) ) \
        .replace( "<__CPP_END_HH_HEADER_GUARD__>", "#endif // " + header_guard_string ) \
        .replace( "<__CPP_ADDITIONAL_FWD_INCLUDES__>", generate_additional_includes( additional_includes, True, dirname_short + apiclassname ) ) \
        .replace( "<__BASE_API_CLASS_NAMESPACE_AND_NAME__>", api_base_class ) \
        .replace( "<__INCLUDE_BASE_API_CLASS_HH_FILE__>", api_base_class_include )

    fname = dirname + apiclassname + ".hh"
    with open( fname, 'w' ) as filehandle :
        filehandle.write(hhfile)
    print( "\tWrote \"" + fname + "\"."  )

## @brief Auto-generate the cc file (***.cc) for the class.
def prepare_cc_file( project_name: str, libraryname : str, classname : str, namespace : list, dirname : str, ccfile_template : str, licence : str, jsonfile : json, tabchar : str, is_lightweight : bool, is_plugin_class : bool  ) :
    apiclassname = classname + "_API"
    original_class_namespace_string = ""
    for i in range( len(namespace) ):
        original_class_namespace_string += namespace[i]
        if i+1<len(namespace) :
            original_class_namespace_string += "::"

    dirname_short = dirname.replace("src/", "")
    namespace_and_source_class = original_class_namespace_string + "::" + classname

    if is_plugin_class == True :
        api_base_class = "masala::base::managers::plugin_module::MasalaPluginAPI"
    else :
        api_base_class = "masala::base::MasalaObjectAPI"

    additional_includes = []

    ccfile = \
        ccfile_template \
        .replace( "<__COMMENTED_LICENCE__>", "/*\n" + licence + "\n*/\n" ) \
        .replace( "<__DOXYGEN_FILE_PATH_AND_CC_FILE_NAME__>", "/// @file " + dirname_short + apiclassname + ".cc" ) \
        .replace( "<__DOXYGEN_BRIEF_DESCRIPTION__>", "/// @brief Implementations for auto-generated API for\n/// " + namespace_and_source_class + " class." ) \
        .replace( "<__DOXYGEN_DETAILED_DESCRIPTION__>", "/// @details This file was generated automatically.  Do not edit it, for changes\n/// will be lost on next rebuild." ) \
        .replace( "<__DOXYGEN_AUTHOR_AND_EMAIL__>", "/// @author None (auto-generated by script code_templates/generate_library_api.py)." ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE_AND_NAME__>", namespace_and_source_class ) \
        .replace( "<__SOURCE_CLASS_NAME__>", classname ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE__>", original_class_namespace_string ) \
        .replace( "<__CPP_NAMESPACE__>", generate_cpp_namespace( namespace, True ) ) \
        .replace( "<__CPP_END_NAMESPACE__>", generate_cpp_namespace( namespace, False ) ) \
        .replace( "<__SOURCE_CLASS_API_NAME__>", apiclassname ) \
        .replace( "<__SOURCE_CLASS_API_NAMESPACE__>", generate_cpp_namespace_singleline( namespace ) ) \
        .replace( "<__INCLUDE_FILE_PATH_AND_HH_FILE_NAME__>", "#include <" + dirname_short + apiclassname + ".hh>" ) \
        .replace( "<__INCLUDE_SOURCE_FILE_PATH_AND_HH_FILE_NAME__>", "#include <" + generate_source_class_filename( classname, namespace, ".hh" ) + ">" ) \
        .replace( "<__CPP_CONSTRUCTOR_IMPLEMENTATIONS__>", generate_constructor_implementations(project_name, namespace_and_source_class, jsonfile, tabchar, additional_includes, is_lightweight, is_plugin_class=is_plugin_class) ) \
        .replace( "<__CPP_SETTER_IMPLEMENTATIONS__>", generate_function_implementations(project_name, namespace_and_source_class, jsonfile, tabchar, "SETTER", additional_includes, is_lightweight) ) \
        .replace( "<__CPP_GETTER_IMPLEMENTATIONS__>", generate_function_implementations(project_name, namespace_and_source_class, jsonfile, tabchar, "GETTER", additional_includes, is_lightweight) ) \
        .replace( "<__CPP_WORK_FUNCTION_IMPLEMENTATIONS__>", generate_function_implementations(project_name, namespace_and_source_class, jsonfile, tabchar, "WORKFXN", additional_includes, is_lightweight) ) \
        .replace( "<__CPP_ADDITIONAL_HH_INCLUDES__>", generate_additional_includes( additional_includes, False, dirname_short + apiclassname ) ) \
        .replace( "<__BASE_API_CLASS_NAMESPACE_AND_NAME__>", api_base_class )

    fname = dirname + apiclassname + ".cc"
    with open( fname, 'w' ) as filehandle :
        filehandle.write(ccfile)
    print( "\tWrote \"" + fname + "\"."  )

## @brief Given the project name, capitalize it.
def capitalize_project_name( project_name: str ) -> str :
    namesplit = project_name.replace("_", " ").split()
    outname = ""
    for word in namesplit :
        if outname != "" :
            outname += "_"
        if len(word) > 0 :
            outname += word[0].capitalize()
        if len(word) > 1 :
            outname += word[1:]
    return outname

## @brief Given library name, class name, class namespace, and project name, return the name of the
## creator class, the namespace of the creator class (as a list), and the filename (without extension) of the
## creator class source.
def determine_creator_name_namespace_filename( library_name : str, name_string : str, namespace : list, project_name : str ) -> tuple :
    creator_name = name_string + "Creator"
    creator_namespace = [ project_name, library_name + "_api", "auto_generated_api" ]
    creator_filename_no_extension = "src/" + library_name + "_api/auto_generated_api"
    assert len(namespace) >= 2
    for i in range( len(namespace) ) :
        if i == 0 :
            assert namespace[i] == project_name
        elif i == 1 :
            assert namespace[i] == library_name
        else :
            creator_namespace.append( namespace[i] )
            creator_filename_no_extension += "/" + namespace[i]
    creator_filename_no_extension += "/" + creator_name
    #print( creator_name, creator_namespace, creator_filename_no_extension )
    return creator_name, creator_namespace, creator_filename_no_extension


## @brief If we have plugins, copy the registration file templates and fill them in.
def do_generate_registration_function( \
    project_name : str, \
    library_name : str, \
    plugins_list : list, \
    plugin_registration_ccfile_template : str, \
    plugin_registration_hhfile_template : str, \
    licence : str \
    ) -> None :

    #Prepare the directory:
    registration_dirname = "src/" + library_name  + "_api/auto_generated_api/registration"
    if os.path.isdir( registration_dirname ) :
        print( "\tFound directory \"" + registration_dirname + "\".  Clearing contents." )
        shutil.rmtree( registration_dirname )
    else :
        print( "\tCreating \"" + registration_dirname + "\"." )
    os.makedirs( registration_dirname )

    #Prepare plugin .hh files list:
    first = True
    plugin_hh_files_includes = ""
    for entry in plugins_list :
        if first == True :
            first = False
        else :
            plugin_hh_files_includes += "\n"
        plugin_hh_files_includes += "#include <" + entry[2][4:] + ".hh>"

    #Prepare namespace:
    namespace_open = "namespace " + project_name + " {\nnamespace " + library_name + " {\nnamespace auto_generated_api {\nnamespace registration {"
    namespace_close = "} // namespace registration\n} // namespace auto_generated_api\n} // namespace " + library_name + "\n} // namespace " + project_name

    #Prepare cc file:
    cc_fname = registration_dirname + "/register_" + library_name + ".cc"

    ccfile = plugin_registration_ccfile_template \
        .replace( "<__COMMENTED_LICENCE__>", "/*\n" + licence + "\n*/\n" ) \
        .replace( "<__DOXYGEN_FILE_PATH_AND_CC_FILE_NAME__>", "/// @file " + cc_fname ) \
        .replace( "<__DOXYGEN_BRIEF_DESCRIPTION__>", "/// @brief Implementations of registration functions for the " + library_name + " library plugins." ) \
        .replace( "<__DOXYGEN_AUTHOR_AND_EMAIL__>", "/// @author None (auto-generated by script code_templates/generate_library_api.py)." ) \
        .replace( "<__PLUGIN_CREATOR_HH_FILES_INCLUDES__>", plugin_hh_files_includes ) \
        .replace( "<__CPP_NAMESPACE__>", namespace_open ) \
        .replace( "<__CPP_END_NAMESPACE__>", namespace_close ) \
        .replace( "<__LIBNAME__>", library_name )

    with open( cc_fname, 'w' ) as filehandle :
        filehandle.write(ccfile)
    print( "\tWrote \"" + cc_fname + "\"."  )

    #Prepare hh file:
    # hh_fname = registration_dirname + "/register_" + library_name + ".hh"
    # with open( hh_fname, 'w' ) as filehandle :
    #     filehandle.write(hhfile)
    # print( "\tWrote \"" + hh_fname + "\"."  )


################################################################################
## Program entry point
################################################################################

# Get options
project_name, library_name, api_def_file = get_options()
print( "\tGenerating API for project " + project_name + ", library \"" + library_name + "\" from API definition file \"" + api_def_file + "\"." )

# Read JSON
with open( api_def_file, 'r' ) as jfile :
    json_api = json.load( jfile )

initialize_directory( library_name )
ccfile_template = read_file( "code_templates/api_templates/MasalaClassAPI.cc" )
hhfile_template = read_file( "code_templates/api_templates/MasalaClassAPI.hh" )
fwdfile_template = read_file( "code_templates/api_templates/MasalaClassAPI.fwd.hh" )

lightweight_ccfile_template = read_file( "code_templates/api_templates/MasalaLightWeightClassAPI.cc" )
lightweight_hhfile_template = read_file( "code_templates/api_templates/MasalaLightWeightClassAPI.hh" )
lightweight_fwdfile_template = read_file( "code_templates/api_templates/MasalaLightWeightClassAPI.fwd.hh" )

plugin_creator_ccfile_template = read_file( "code_templates/api_templates/MasalaPluginCreator.cc" )
plugin_creator_hhfile_template = read_file( "code_templates/api_templates/MasalaPluginCreator.hh" )
plugin_creator_fwdfile_template = read_file( "code_templates/api_templates/MasalaPluginCreator.fwd.hh" )

plugin_registration_ccfile_template = read_file( "code_templates/api_templates/register_plugins.cc" )
plugin_registration_hhfile_template = read_file( "code_templates/api_templates/register_plugins.hh" )

project_name_capitalized = capitalize_project_name( project_name ).replace( "_", " " )
licence_template = read_file( "code_templates/licences/AGPL3.template" ).replace( "<__PROJECT_NAME__>", project_name_capitalized ).replace( "<__YEAR__>", str(2022) ).replace( "<__COPYRIGHT_HOLDER__>", "Vikram K. Mulligan" )
tabchar = "    "

generate_registration_function = False
plugins_list = []

if json_api["Elements"] is not None :
    for element in json_api["Elements"] :
        #print( element )
        namespace_string = json_api["Elements"][element]["ModuleNamespace"]
        name_string = json_api["Elements"][element]["Module"]
        namespace = separate_namespace( namespace_string )
        #print( namespace_string, name_string )
        #print( namespace )
        assert len(namespace) > 2
        assert namespace[0] == project_name, "Error!  All Masla classes (with or without APIs) are expected to be in base namespace \"" + project_name + "\".  This doesn't seem to be so for " + namespace_string + "::" + name_string + "."
        assert namespace[1] == library_name, "Error!  All Masla classes in library " + library_name + " (with or without APIs) are expected to be in namespace \"" + project_name + "::" + library_name + "\".  This doesn't seem to be so for " + namespace_string + "::" + name_string + "."
        dirname = prepare_directory( project_name, library_name, namespace )
        is_plugin_class = json_api["Elements"][element]["Properties"]["Is_Plugin_Class"]
        if json_api["Elements"][element]["Properties"]["Is_Lightweight"] == False :
            prepare_forward_declarations( library_name, name_string, namespace, dirname, fwdfile_template, licence_template )
            prepare_header_file( project_name, library_name, name_string, namespace, dirname, hhfile_template, licence_template, json_api, tabchar, is_plugin_class=is_plugin_class )
            prepare_cc_file( project_name, library_name, name_string, namespace, dirname, ccfile_template, licence_template, json_api, tabchar, False, is_plugin_class=is_plugin_class )
        else :
            prepare_forward_declarations( library_name, name_string, namespace, dirname, lightweight_fwdfile_template, licence_template )
            prepare_header_file( project_name, library_name, name_string, namespace, dirname, lightweight_hhfile_template, licence_template, json_api, tabchar, is_plugin_class=is_plugin_class )
            prepare_cc_file( project_name, library_name, name_string, namespace, dirname, lightweight_ccfile_template, licence_template, json_api, tabchar, True, is_plugin_class=is_plugin_class )
        
        if is_plugin_class == True :
            generate_registration_function = True
            creator_name,creator_namespace,creator_filename = determine_creator_name_namespace_filename( library_name, name_string, namespace, project_name )
            plugins_list.append( [creator_name,creator_namespace,creator_filename] )
            prepare_creator_forward_declarations( plugin_creator_fwdfile_template, licence_template, creator_name, creator_namespace, creator_filename, json_api, name_string, namespace, library_name, project_name  )
            prepare_creator_header_file( plugin_creator_hhfile_template, licence_template, creator_name, creator_namespace, creator_filename, json_api, name_string, namespace, library_name, project_name  )
            prepare_creator_cc_file( plugin_creator_ccfile_template, licence_template, creator_name, creator_namespace, creator_filename, json_api, name_string, namespace, library_name, project_name, dirname  )
    
    if generate_registration_function == True :
        do_generate_registration_function( project_name, library_name, plugins_list, plugin_registration_ccfile_template, plugin_registration_hhfile_template, licence_template )

print( "\tFinished generating API for library \"" + library_name + "\" from API definition file \"" + api_def_file + "\"." )
    