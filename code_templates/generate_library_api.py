# MIT License
#
# Copyright (c) 2022 Vikram K. Mulligan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

## @file code_templates/generate_library_api.py
## @brief Used during the build process to produce the auto-generated API layer code.
## @details Usage:
##          python3 generate_library_api.py <source library name> <json api definition file>
## @note The source library name is something like "core".  This Python code would then
## produce code in "core_api/auto_generated_api/".  This file should be run from the Masala
## root directory.
## @author Vikram K. Mulligan (vmulligan@flatironinstitute.org).

from dbm.ndbm import library
from genericpath import isdir
import json
from re import split as regex_split
from sys import argv
import os
import shutil
from copy import copy

## @brief Parse the commandline options.
## @returns Source library name, JSON API definition file.  Throws if
## these two options aren't provided.
def get_options() -> tuple :
    assert len(argv) == 3, "Invalid commandline flags.  Expected usage: python3 generate_library_api.py <source library name> <json api definition file>"
    return (argv[1], argv[2])

## @brief Initialize the auto_generated_api directory, creating it if it does
## not exist and deleting anything in it if it does.
## @brief Puts a README.txt file in the directory indicating that it is auto-
## generated, and that no one should put anything in there manually.
def initialize_directory( library_name : str ) -> None :
    assert os.path.isdir( "src/" + library_name + "_api" ), "Error in generate_library_api.py: Could not find directory \"src/" + library_name + "\".  Note that this script must be run from the Masala root directory."
    apidir = "src/" + library_name + "_api/auto_generated_api/"
    if os.path.isdir( apidir ) :
        print( "Found directory \"" + apidir + "\".  Clearing contents." )
        shutil.rmtree( apidir )
    else :
        print( "Creating \"" + apidir + "\"." )
    os.makedirs( apidir )
    with open( apidir + "README.txt", 'w' ) as filehandle:
        filehandle.write( "Directory \"" + apidir + "\" is auto-generated by the build process.\n" )
        filehandle.write( "Do not put anything in this directory manually, since it is cleared and regenerated\n" )
        filehandle.write( "each time the build occurs.\n" )
    print( "Wrote \"" + apidir + "README.txt.\"" )
    
## @brief Given a namespace for a class, create a directory in the auto-
## generated API directory with directory structure matching the
## namespace.  If the directory already exists, do nothing.
## @returns The directory name, for reuse later.
def prepare_directory( libname : str, namespace : list ) -> str :
    assert namespace[0] == "masala"
    assert namespace[1] == libname
    dirname = "src/" + libname + "_api/auto_generated_api/"
    for i in range( 2, len(namespace) ) :
        dirname += namespace[i] + "/"
    if os.path.isdir( dirname ) == False :
        print( "Creating \"" + dirname + "\"." )
        os.makedirs( dirname )
    else :
        print( "Directory \"" + dirname + "\" already exists.  Skipping creation." )
    return dirname

## @brief Given a namespace string of the form "XXXX::YYYY::ZZZZ", return a\
## list of [ "XXXX", "YYYY", "ZZZZ" ].
def separate_namespace( namespace_string ) -> list :
    return regex_split( "\:\:" , namespace_string )

## @brief Read a file and return its contents as a string.
def read_file( filename : str ) -> list :
    with open( filename, 'r' ) as filehandle :
        filecontents = filehandle.read()
    print( "Read contents of \"" + filename + "\" into memory." )
    return filecontents

## @brief Given the namespace as a list of strings, generate the C++ namespace lines.
## @details If opening_parentheses is true, we generate the parentheses that open the
## namespace.  Otherwise, we generate the parentheses that close the namespace.
def generate_cpp_namespace( namespace: list, opening_parentheses : bool ) -> str :
    outstr = ""
    for i in range( len(namespace) ) :
        if opening_parentheses == True :
            outstr += "namespace " + namespace[i]
            if i == 1 :
                outstr += "_api {\nnamespace auto_generated_api"
            outstr += " {"
        else :
            curindex = len(namespace) - i - 1
            outstr += "} // namespace " + namespace[curindex]
            if curindex == 1 :
                outstr += "_api\n} // namespace auto_generated_api"
        outstr += "\n"
    return outstr

## @brief Given a source class and namespace, generate the path and filename for a source file
## with a given extension.
def generate_source_class_filename( classname : str, namespace : list, extension : str ) -> str :
    assert len(namespace) >= 2
    outstr = ""
    for i in range( 1, len(namespace) ) :
        outstr += namespace[i]
        outstr += "/"
    outstr += classname + extension
    return outstr

## @brief Generate the prototypes for the constructors based on the JSON description of the API.
## @note The classname input should include namespace.
def generate_constructor_prototypes(classname: str, jsonfile: json, tabchar: str) -> str :
    outstring = ""
    first = True
    for constructor in jsonfile["Elements"][classname]["Constructors"]["Constructor_APIs"] :
        print(constructor)
        if first :
            first = False
        else :
            outstring += "\n\n"
        outstring += tabchar + "/// @brief " + constructor["Constructor_Description"] + "\n"
        ninputs = constructor["Constructor_N_Inputs"]
        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += tabchar + "/// @param[in] " + constructor["Inputs"]["Input_" + str(i+1)]["Input_Name"] + " " + constructor["Inputs"]["Input_" + str(i+1)]["Input_Description"] + "\n"
        outstring += tabchar + constructor["Constructor_Name"] + "("
        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += "\n" + tabchar + tabchar + constructor["Inputs"]["Input_" + str(i+1)]["Input_Type"] + " " + constructor["Inputs"]["Input_" + str(i+1)]["Input_Name"]
            outstring += "\n" + tabchar + ");"
        else :
            outstring += ");"
    return outstring
    
## @brief Auto-generate the forward declaration file (***.fwd.hh) for the class.
def prepare_forward_declarations( libraryname : str, classname : str, namespace : list, dirname : str, fwdfile_template : str, licence : str ) :
    apiclassname = classname + "_API"
    original_class_namespace_string = ""
    header_guard_string = "Masala_" + libraryname + "_api_auto_generated_api_"
    for i in range( len(namespace) ):
        original_class_namespace_string += namespace[i]
        if i+1<len(namespace) :
            original_class_namespace_string += "::"
        if i > 1 :
            header_guard_string += namespace[i] + "_"
    header_guard_string += apiclassname + "_fwd_hh"

    dirname_short = dirname.replace("src/", "")
    namespace_and_source_class = original_class_namespace_string + "::" + classname

    fwdfile = \
        fwdfile_template \
        .replace( "<__COMMENTED_LICENCE__>", "/*\n" + licence + "\n*/\n" ) \
        .replace( "<__DOXYGEN_FILE_PATH_AND_FWD_FILE_NAME__>", "/// @file " + dirname_short + apiclassname + ".fwd.hh" ) \
        .replace( "<__DOXYGEN_FWD_BRIEF_DESCRIPTION__>", "/// @brief Forward declarations for auto-generated API for\n/// " + namespace_and_source_class + " class." ) \
        .replace( "<__DOXYGEN_DETAILED_DESCRIPTION__>", "/// @details This file was generated automatically.  Do not edit it, for changes\n/// will be lost on next rebuild." ) \
        .replace( "<__DOXYGEN_AUTHOR_AND_EMAIL__>", "/// @author None (auto-generated by script code_templates/generate_library_api.py)." ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE_AND_NAME__>", namespace_and_source_class ) \
        .replace( "<__CPP_FWD_HEADER_GUARD__>", "#ifndef " + header_guard_string + "\n#define " + header_guard_string ) \
        .replace( "<__CPP_NAMESPACE__>", generate_cpp_namespace( namespace, True ) ) \
        .replace( "<__CPP_END_NAMESPACE__>", generate_cpp_namespace( namespace, False ) ) \
        .replace( "<__SOURCE_CLASS_API_NAME__>", apiclassname ) \
        .replace( "<__CPP_END_FWD_HEADER_GUARD__>", "#endif // " + header_guard_string )

    fname = dirname + apiclassname + ".fwd.hh"
    with open( fname, 'w' ) as filehandle :
        filehandle.write(fwdfile)
    print( "Wrote \"" + fname + "\"."  )

## @brief Auto-generate the header file (***.hh) for the class.
def prepare_header_file( libraryname : str, classname : str, namespace : list, dirname : str, hhfile_template : str, licence : str, jsonfile : json, tabchar: str ) :
    apiclassname = classname + "_API"
    original_class_namespace_string = ""
    header_guard_string = "Masala_" + libraryname + "_api_auto_generated_api_"
    for i in range( len(namespace) ):
        original_class_namespace_string += namespace[i]
        if i+1<len(namespace) :
            original_class_namespace_string += "::"
        if i > 1 :
            header_guard_string += namespace[i] + "_"
    header_guard_string += apiclassname + "_hh"

    dirname_short = dirname.replace("src/", "")
    namespace_and_source_class = original_class_namespace_string + "::" + classname

    hhfile = \
        hhfile_template \
        .replace( "<__COMMENTED_LICENCE__>", "/*\n" + licence + "\n*/\n" ) \
        .replace( "<__DOXYGEN_FILE_PATH_AND_HH_FILE_NAME__>", "/// @file " + dirname_short + apiclassname + ".hh" ) \
        .replace( "<__DOXYGEN_BRIEF_DESCRIPTION__>", "/// @brief Headers for auto-generated API for\n/// " + namespace_and_source_class + " class." ) \
        .replace( "<__DOXYGEN_DETAILED_DESCRIPTION__>", "/// @details This file was generated automatically.  Do not edit it, for changes\n/// will be lost on next rebuild." ) \
        .replace( "<__DOXYGEN_AUTHOR_AND_EMAIL__>", "/// @author None (auto-generated by script code_templates/generate_library_api.py)." ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE_AND_NAME__>", namespace_and_source_class ) \
        .replace( "<__CPP_HH_HEADER_GUARD__>", "#ifndef " + header_guard_string + "\n#define " + header_guard_string ) \
        .replace( "<__CPP_NAMESPACE__>", generate_cpp_namespace( namespace, True ) ) \
        .replace( "<__CPP_END_NAMESPACE__>", generate_cpp_namespace( namespace, False ) ) \
        .replace( "<__SOURCE_CLASS_API_NAME__>", apiclassname ) \
        .replace( "<__INCLUDE_FILE_PATH_AND_FWD_FILE_NAME__>", "#include <" + dirname_short + apiclassname + ".fwd.hh" ) \
        .replace( "<__INCLUDE_SOURCE_FILE_PATH_AND_FWD_FILE_NAME__>", "#include <" + generate_source_class_filename( classname, namespace, ".fwd.hh" ) + ">" ) \
        .replace( "<__CPP_CONSTRUCTOR_PROTOTYPES__>", generate_constructor_prototypes(namespace_and_source_class, jsonfile, tabchar) ) \
        .replace( "<__CPP_END_HH_HEADER_GUARD__>", "#endif // " + header_guard_string )

    fname = dirname + apiclassname + ".hh"
    with open( fname, 'w' ) as filehandle :
        filehandle.write(hhfile)
    print( "Wrote \"" + fname + "\"."  )


################################################################################
## Program entry point
################################################################################

# Get options
library_name, api_def_file = get_options()
print( "Generating API for library \"" + library_name + "\" from API definition file \"" + api_def_file + "\"." )

# Read JSON
with open( api_def_file, 'r' ) as jfile :
    json_api = json.load( jfile )

initialize_directory( library_name )
ccfile_template = read_file( "code_templates/api_templates/MasalaClassAPI.cc" )
hhfile_template = read_file( "code_templates/api_templates/MasalaClassAPI.hh" )
fwdfile_template = read_file( "code_templates/api_templates/MasalaClassAPI.fwd.hh" )
licence_template = read_file( "code_templates/licences/MIT.template" ).replace( "<__YEAR__>", str(2022) ).replace( "<__COPYRIGHT_HOLDER__>", "Vikram K. Mulligan" )
tabchar = "    "

for element in json_api["Elements"] :
    #print( element )
    namespace_string = json_api["Elements"][element]["ModuleNamespace"]
    name_string = json_api["Elements"][element]["Module"]
    namespace = separate_namespace( namespace_string )
    #print( namespace_string, name_string )
    #print( namespace )
    assert len(namespace) > 2
    assert namespace[0] == "masala", "Error!  All Masla classes (with or without APIs) are expected to be in base namespace \"masala\".  This doesn't seem to be so for " + namespace_string + "::" + name_string + "."
    assert namespace[1] == library_name, "Error!  All Masla classes in library " + library_name + " (with or without APIs) are expected to be in namespace \"masala::" + library_name + "\".  This doesn't seem to be so for " + namespace_string + "::" + name_string + "."
    dirname = prepare_directory( library_name, namespace )
    prepare_forward_declarations( library_name, name_string, namespace, dirname, fwdfile_template, licence_template )
    prepare_header_file( library_name, name_string, namespace, dirname, hhfile_template, licence_template, json_api, tabchar )
    #prepare_cc_file( name_string, namespace, dirname, ccfile_template, licence_template )
    