# MIT License
#
# Copyright (c) 2022 Vikram K. Mulligan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

## @file code_templates/generate_library_api.py
## @brief Used during the build process to produce the auto-generated API layer code.
## @details Usage:
##          python3 generate_library_api.py <source library name> <json api definition file>
## @note The source library name is something like "core".  This Python code would then
## produce code in "core_api/auto_generated_api/".  This file should be run from the Masala
## root directory.
## @author Vikram K. Mulligan (vmulligan@flatironinstitute.org).

from dbm.ndbm import library
from genericpath import isdir
import json
from re import split as regex_split
from sys import argv
import os
import shutil
from copy import copy

## @brief Parse the commandline options.
## @returns Source library name, JSON API definition file.  Throws if
## these two options aren't provided.
def get_options() -> tuple :
    assert len(argv) == 3, "Invalid commandline flags.  Expected usage: python3 generate_library_api.py <source library name> <json api definition file>"
    return (argv[1], argv[2])

## @brief Initialize the auto_generated_api directory, creating it if it does
## not exist and deleting anything in it if it does.
## @brief Puts a README.txt file in the directory indicating that it is auto-
## generated, and that no one should put anything in there manually.
def initialize_directory( library_name : str ) -> None :
    assert os.path.isdir( "src/" + library_name + "_api" ), "Error in generate_library_api.py: Could not find directory \"src/" + library_name + "\".  Note that this script must be run from the Masala root directory."
    apidir = "src/" + library_name + "_api/auto_generated_api/"
    if os.path.isdir( apidir ) :
        print( "\tFound directory \"" + apidir + "\".  Clearing contents." )
        shutil.rmtree( apidir )
    else :
        print( "\tCreating \"" + apidir + "\"." )
    os.makedirs( apidir )
    with open( apidir + "README.txt", 'w' ) as filehandle:
        filehandle.write( "Directory \"" + apidir + "\" is auto-generated by the build process.\n" )
        filehandle.write( "Do not put anything in this directory manually, since it is cleared and regenerated\n" )
        filehandle.write( "each time the build occurs.\n" )
    print( "\tWrote \"" + apidir + "README.txt.\"" )
    
## @brief Given a namespace for a class, create a directory in the auto-
## generated API directory with directory structure matching the
## namespace.  If the directory already exists, do nothing.
## @returns The directory name, for reuse later.
def prepare_directory( libname : str, namespace : list ) -> str :
    assert namespace[0] == "masala"
    assert namespace[1] == libname
    dirname = "src/" + libname + "_api/auto_generated_api/"
    for i in range( 2, len(namespace) ) :
        dirname += namespace[i] + "/"
    if os.path.isdir( dirname ) == False :
        print( "\tCreating \"" + dirname + "\"." )
        os.makedirs( dirname )
    else :
        print( "\tDirectory \"" + dirname + "\" already exists.  Skipping creation." )
    return dirname

## @brief Given a namespace string of the form "XXXX::YYYY::ZZZZ", return a\
## list of [ "XXXX", "YYYY", "ZZZZ" ].
def separate_namespace( namespace_string ) -> list :
    return regex_split( "\:\:" , namespace_string )

## @brief Read a file and return its contents as a string.
def read_file( filename : str ) -> list :
    with open( filename, 'r' ) as filehandle :
        filecontents = filehandle.read()
    print( "\tRead contents of \"" + filename + "\" into memory." )
    return filecontents

## @brief Determine whether an object is an API type, and if so, access the
## class type inside.
def access_needed_object( classname : str, instancename : str, jsonfile : json ) -> str :
    if classname.startswith( "masala::" ) == False :
        if classname.startswith( "std::shared_ptr" ) :
            firstchevron = inputclass.find( "<" )
            lastchevron = inputclass.rfind( ">" )
            innerclass = classname[firstchevron+1:lastchevron].strip()
            if innerclass.startswith("masala::") :
                return instancename + "->get_inner_object()"
        return instancename #Not an API class
    classtype = classname.split()[0]
    assert classtype in jsonfile["Elements"]
    if jsonfile["Elements"][classtype]["Properties"]["Is_Lightweight"]:
        return instancename + ".get_inner_object()"
    return "*( " + instancename + ".get_inner_object() )"

## @brief Given a Masala type that may contain "const", drop the const.
def drop_const( classname: str )-> str :
    classname_split = classname.split()
    outstr = ""
    first = True
    for entry in classname_split :
        if entry != "const" :
            if first == False :
                outstr += " "
            else :
                first = False
            outstr += entry
    return outstr

## @brief Add a Masala header to the list of additional headers to include.
def add_base_class_include( inputclass : str , additional_includes: list ) -> None :
    if inputclass.startswith( "masala::" ) == False :
        # Do nothing.
        return
    includefile = inputclass[8:].replace( "::", "/" )
    if includefile not in additional_includes :
        additional_includes.append(includefile)

## @brief Given a class name, construct the name of the API class (if it is a Masala class)
## or do nothing (if it is not a Masala class.)
## @details Has certain exceptions, like masala::base::api::MasalaObjectAPIDefinition.
## @note As a side-effect, this populates the additional_includes list with files to include
## for the additional API classes.  Each entry added is first checked so that it is not added
## multiple times.  The extension (.hh or .fwd.hh) is omitted.
def correct_masala_types( inputclass : str, additional_includes: list ) -> str :
    #print( inputclass )
    if inputclass.startswith( "masala::" ) == False :
        if inputclass.startswith( "std::shared_ptr" ) :
            firstchevron = inputclass.find( "<" )
            lastchevron = inputclass.rfind( ">" )
            return "std::shared_ptr< " + correct_masala_types( inputclass[firstchevron + 1 : lastchevron].strip(), additional_includes ) + " >"
        # elif inputclass.startswith( "std::weak_ptr" ) :
        #     firstchevron = inputclass.find( "<" )
        #     lastchevron = inputclass.rfind( ">" )
        #     return "std::weak_ptr< " + correct_masala_types( inputclass[firstchevron + 1 : lastchevron].strip(), additional_includes ) + " >"
        return inputclass # Do nothing if ths isn't a masala class.
    
    api_classname = ""
    api_filename = ""
    firstspace = inputclass.find(" ")
    if firstspace == -1 :
        inputclass_base = inputclass
        inputclass_extension = ""
    else :
        inputclass_base = inputclass[0:firstspace]
        inputclass_extension = inputclass[firstspace + 1:]
    inputclass_split = inputclass_base.split("::")
    assert len(inputclass_split) > 2
    for i in range(len(inputclass_split)) :
        if i == 0 :
            continue # Skip "masala"
        curstring = inputclass_split[i]
        api_classname += curstring
        api_filename += curstring
        if i == 1 :
            api_classname += "_api::auto_generated_api"
            api_filename += "_api/auto_generated_api"
        if i == len(inputclass_split) - 1 :
            api_classname += "_API"
            api_filename += "_API"
        else :
            api_classname += "::"
            api_filename += "/"
    if api_filename not in additional_includes :
        additional_includes.append( api_filename )
    if len(inputclass_extension) > 0 :
        return api_classname + " " + inputclass_extension
    return api_classname

    

## @brief Given the namespace as a list of strings, generate the C++ namespace lines.
## @details If opening_parentheses is true, we generate the parentheses that open the
## namespace.  Otherwise, we generate the parentheses that close the namespace.
def generate_cpp_namespace( namespace: list, opening_parentheses : bool ) -> str :
    outstr = ""
    for i in range( len(namespace) ) :
        if opening_parentheses == True :
            outstr += "namespace " + namespace[i]
            if i == 1 :
                outstr += "_api {\nnamespace auto_generated_api"
            outstr += " {"
        else :
            curindex = len(namespace) - i - 1
            outstr += "} // namespace " + namespace[curindex]
            if curindex == 1 :
                outstr += "_api\n} // namespace auto_generated_api"
        outstr += "\n"
    return outstr

## @brief Given the namespace as a list of strings, generate the C++ namespace for the API
## as a single line (separated by double colons):
def generate_cpp_namespace_singleline( namespace: list ) -> str :
    outstr = ""
    first = True
    for i in range( len( namespace ) ) :
        if first == True :
            first = False
        else :
            outstr += "::"
        outstr += namespace[i]
        if i == 1 :
            outstr += "_api::auto_generated_api"
    return outstr

## @brief Given a source class and namespace, generate the path and filename for a source file
## with a given extension.
def generate_source_class_filename( classname : str, namespace : list, extension : str ) -> str :
    assert len(namespace) >= 2
    outstr = ""
    for i in range( 1, len(namespace) ) :
        outstr += namespace[i]
        outstr += "/"
    outstr += classname + extension
    return outstr

## @brief Generate the prototypes for the constructors based on the JSON description of the API.
## @note The classname input should include namespace.
def generate_constructor_prototypes(classname: str, jsonfile: json, tabchar: str, additional_includes: list) -> str :
    outstring = ""
    first = True
    for constructor in jsonfile["Elements"][classname]["Constructors"]["Constructor_APIs"] :
        #print(constructor)
        if first :
            first = False
        else :
            outstring += "\n\n"
        outstring += tabchar + "/// @brief " + constructor["Constructor_Description"] + "\n"
        ninputs = constructor["Constructor_N_Inputs"]
        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += tabchar + "/// @param[in] " + constructor["Inputs"]["Input_" + str(i)]["Input_Name"] + " " + constructor["Inputs"]["Input_" + str(i)]["Input_Description"] + "\n"
        outstring += tabchar + constructor["Constructor_Name"] + "_API("
        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += "\n" + tabchar + tabchar + correct_masala_types( constructor["Inputs"]["Input_" + str(i)]["Input_Type"], additional_includes ) + " " + constructor["Inputs"]["Input_" + str(i)]["Input_Name"]
            outstring += "\n" + tabchar + ");"
        else :
            outstring += ");"
    return outstring

## @brief Generate the implementations for the constructors based on the JSON description of the API.
## @note The classname input should include namespace.
def generate_constructor_implementations(classname: str, jsonfile: json, tabchar: str, additional_includes: list) -> str :
    outstring = ""
    first = True
    for constructor in jsonfile["Elements"][classname]["Constructors"]["Constructor_APIs"] :
        #print(constructor)
        if first :
            first = False
        else :
            outstring += "\n\n"
        outstring += "/// @brief " + constructor["Constructor_Description"] + "\n"
        ninputs = constructor["Constructor_N_Inputs"]
        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += "/// @param[in] " + constructor["Inputs"]["Input_" + str(i)]["Input_Name"] + " " + constructor["Inputs"]["Input_" + str(i)]["Input_Description"] + "\n"
        outstring += constructor["Constructor_Name"] + "_API::" + constructor["Constructor_Name"] + "_API("
        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += "\n" + tabchar + correct_masala_types( constructor["Inputs"]["Input_" + str(i)]["Input_Type"], additional_includes ) + " " + constructor["Inputs"]["Input_" + str(i)]["Input_Name"]
            outstring += "\n" + ") :\n"
        else :
            outstring += ") :\n"
        
        # Initialization:
        outstring += tabchar + "base_api::MasalaObjectAPI(),\n"
        outstring += tabchar + "inner_object_( std::make_shared< " + classname + " >("
        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += " " + access_needed_object( constructor["Inputs"]["Input_" + str(i)]["Input_Type"], constructor["Inputs"]["Input_" + str(i)]["Input_Name"], jsonfile )
                if i+1 < ninputs :
                    outstring += ","
                else :
                    outstring += " "
        outstring +=") )\n"

        # Body:
        outstring += "{}"
    return outstring

## @brief Generate the prototypes for setters, getters, or work functions based on the JSON
## description of the API.
## @note The classname input should include namespace.  As a side-effect, this function appends to the
## additional_includes list.
def generate_function_prototypes( classname: str, jsonfile: json, tabchar: str, fxn_type: str, additional_includes: list) -> str :
    outstring = ""
    first = True

    assert fxn_type == "SETTER" or fxn_type == "GETTER" or fxn_type == "WORKFXN"
    if fxn_type == "SETTER" :
        groupname = "Setters"
        namepattern = "Setter"
    elif fxn_type == "GETTER" :
        groupname = "Getters"
        namepattern = "Getter"
    elif fxn_type == "WORKFXN" :
        groupname = "WorkFunctions"
        namepattern = "Work_Function"

    for fxn in jsonfile["Elements"][classname][groupname][namepattern+"_APIs"] :
        #print(fxn)
        if first :
            first = False
        else :
            outstring += "\n\n"
        outstring += tabchar + "/// @brief " + fxn[namepattern+"_Description"] + "\n"
        ninputs = fxn[namepattern+"_N_Inputs"]
        if ("Output" in fxn) and (fxn["Output"]["Output_Type"] != "void") :
            has_output = True
        else :
            has_output = False

        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += tabchar + "/// @param[in] " + fxn["Inputs"]["Input_" + str(i)]["Input_Name"] + " " + fxn["Inputs"]["Input_" + str(i)]["Input_Description"] + "\n"
        if has_output :
            outstring += tabchar + "/// @returns " + fxn["Output"]["Output_Description"] + "\n"
            outstring += tabchar + correct_masala_types( fxn["Output"]["Output_Type"], additional_includes ) + "\n"
        else :
            outstring += tabchar + "void\n"
        outstring += tabchar + fxn[namepattern + "_Name"] + "("

        if fxn["Is_Const"] == True :
            conststr = " const"
        else :
            conststr = ""

        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += "\n" + tabchar + tabchar + correct_masala_types( fxn["Inputs"]["Input_" + str(i)]["Input_Type"], additional_includes ) + " " + fxn["Inputs"]["Input_" + str(i)]["Input_Name"]
            outstring += "\n" + tabchar + ")" + conststr + ";"
        else :
            outstring += ")" + conststr + ";"
    return outstring

## @brief Generate the implementations for setters, getters, or work functions based on the JSON
## description of the API.
## @note The classname input should include namespace.  As a side-effect, this function appends to the
## additional_includes list.
def generate_function_implementations( classname: str, jsonfile: json, tabchar: str, fxn_type: str, additional_includes: list, is_lightweight: bool ) -> str :
    outstring = ""
    first = True

    assert fxn_type == "SETTER" or fxn_type == "GETTER" or fxn_type == "WORKFXN"
    if fxn_type == "SETTER" :
        groupname = "Setters"
        namepattern = "Setter"
    elif fxn_type == "GETTER" :
        groupname = "Getters"
        namepattern = "Getter"
    elif fxn_type == "WORKFXN" :
        groupname = "WorkFunctions"
        namepattern = "Work_Function"

    apiclassname = jsonfile["Elements"][classname]["Module"] + "_API"

    for fxn in jsonfile["Elements"][classname][groupname][namepattern+"_APIs"] :
        #print(fxn)
        if first :
            first = False
        else :
            outstring += "\n\n"
        outstring += "/// @brief " + fxn[namepattern+"_Description"] + "\n"
        ninputs = fxn[namepattern+"_N_Inputs"]
        outtype = fxn["Output"]["Output_Type"]
        if ("Output" in fxn) and (outtype != "void") :
            has_output = True
        else :
            has_output = False

        if ( "Returns_This_Ref" in fxn ) and ( fxn["Returns_This_Ref"] == True ) :
            returns_this_ref = True
        else :
            returns_this_ref = False

        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += "/// @param[in] " + fxn["Inputs"]["Input_" + str(i)]["Input_Name"] + " " + fxn["Inputs"]["Input_" + str(i)]["Input_Description"] + "\n"
        if has_output :
            outstring += "/// @returns " + fxn["Output"]["Output_Description"] + "\n"
            outstring += correct_masala_types( outtype, additional_includes ) + "\n"
        else :
            outstring += "void\n"
        outstring +=  apiclassname + "::" + fxn[namepattern + "_Name"] + "("

        if fxn["Is_Const"] == True :
            conststr = " const"
        else :
            conststr = ""

        if ninputs > 0 :
            for i in range(ninputs) :
                outstring += "\n" + tabchar + tabchar + correct_masala_types( fxn["Inputs"]["Input_" + str(i)]["Input_Type"], additional_includes ) + " " + fxn["Inputs"]["Input_" + str(i)]["Input_Name"]
            outstring += "\n)" + conststr + " {\n"
        else :
            outstring += ")" + conststr + " {\n"

        # Body:

        ismasalaAPIptr = False
        ismasalaAPIobj = False
        if outtype.startswith( "std::shared_ptr" ) :
            firstchevron = outtype.find("<")
            lastchevron = outtype.rfind(">")
            outtype_inner = outtype[firstchevron+1:lastchevron].strip()
            if( outtype_inner.startswith("masala::") ) :
                ismasalaAPIptr = True
        elif outtype.startswith( "masala::" ) and returns_this_ref == False :
            ismasalaAPIobj = True

        outstring += tabchar + "std::lock_guard< std::mutex > lock( api_mutex_ );\n"
        if (fxn_type == "GETTER" or fxn_type == "WORKFXN") and has_output == True and returns_this_ref == False :
            if ismasalaAPIptr :
                outstring += tabchar + "// On the following line, note that std::const_pointer_cast is safe to use.  We\n"
                outstring += tabchar + "// cast away the constness of the object, but effectively restore it by encapsulating\n"
                outstring += tabchar + "// it in an API object that only allows const access.  This is ONLY allowed in Masala\n"
                outstring += tabchar + "// code that is auto-generated in a manner that ensures that nothing unsafe is done\n"
                outstring += tabchar + "// with the nonconst object.\n"
            outstring += tabchar + "return "

            if ismasalaAPIptr and returns_this_ref == False :
                dummy = []
                outstring += "std::make_shared< " + correct_masala_types( outtype_inner, dummy ) + " >(\n"
                outstring += tabchar + tabchar + "std::const_pointer_cast< " + drop_const( outtype_inner ) + " >(\n"
                outstring += tabchar + tabchar + tabchar
            elif ismasalaAPIobj :
                dummy = []
                outstring += correct_masala_types( outtype, dummy ) + "(\n"
                outstring += tabchar + tabchar + "std::make_shared< " + outtype + " >( "
                add_base_class_include( outtype, additional_includes )
        else :
            outstring += tabchar

        accessor_string = "->"
        if is_lightweight == True :
            accessor_string = "."
        outstring += "inner_object_" + accessor_string + fxn[namepattern + "_Name"] + "("
        if ninputs > 0 :
            for i in range(ninputs) :
                if fxn["Inputs"]["Input_" + str(i)]["Input_Type"].startswith( "masala::" ) :
                    inputtype = fxn["Inputs"]["Input_" + str(i)]["Input_Type"].split()[0] 
                    assert inputtype in jsonfile["Elements"]
                    if jsonfile["Elements"][inputtype]["Properties"]["Is_Lightweight"] == True :
                        outstring += fxn["Inputs"]["Input_" + str(i)]["Input_Name"] + ".get_inner_object()"
                    else :
                        outstring += " *( " + fxn["Inputs"]["Input_" + str(i)]["Input_Name"] + ".get_inner_object() )"
                else:
                    outstring += " " + fxn["Inputs"]["Input_" + str(i)]["Input_Name"]
                if i+1 < ninputs :
                    outstring += ","
                else :
                    outstring += " "
        outstring += ")"
        if ismasalaAPIptr and returns_this_ref == False :
            outstring += "\n" + tabchar + tabchar + ")\n" + tabchar + ")"
        elif ismasalaAPIobj and returns_this_ref == False :
            outstring += " )\n" + tabchar + ")"
        outstring += ";\n"
        if returns_this_ref == True :
            outstring += tabchar + "return *this;\n"
        outstring += "}"
    return outstring

## @brief Given a list of additional files to include, generate a
## string of the inclusions.
def generate_additional_includes( additional_includes : list, generate_fwd_includes : bool, original_api_include: str ) -> str :
    outstr = ""
    if generate_fwd_includes == True :
        fwdstr = ".fwd"
    else :
        fwdstr = ""
    first = True
    for entry in additional_includes :
        if entry != original_api_include :
            if first == True :
                first = False
            else :
                outstr += "\n"
            outstr += "#include <" + entry + fwdstr + ".hh>"
    return outstr
    
## @brief Auto-generate the forward declaration file (***.fwd.hh) for the class.
def prepare_forward_declarations( libraryname : str, classname : str, namespace : list, dirname : str, fwdfile_template : str, licence : str ) :
    apiclassname = classname + "_API"
    original_class_namespace_string = ""
    header_guard_string = "Masala_" + libraryname + "_api_auto_generated_api_"
    for i in range( len(namespace) ):
        original_class_namespace_string += namespace[i]
        if i+1<len(namespace) :
            original_class_namespace_string += "::"
        if i > 1 :
            header_guard_string += namespace[i] + "_"
    header_guard_string += apiclassname + "_fwd_hh"

    dirname_short = dirname.replace("src/", "")
    namespace_and_source_class = original_class_namespace_string + "::" + classname

    fwdfile = \
        fwdfile_template \
        .replace( "<__COMMENTED_LICENCE__>", "/*\n" + licence + "\n*/\n" ) \
        .replace( "<__DOXYGEN_FILE_PATH_AND_FWD_FILE_NAME__>", "/// @file " + dirname_short + apiclassname + ".fwd.hh" ) \
        .replace( "<__DOXYGEN_FWD_BRIEF_DESCRIPTION__>", "/// @brief Forward declarations for auto-generated API for\n/// " + namespace_and_source_class + " class." ) \
        .replace( "<__DOXYGEN_DETAILED_DESCRIPTION__>", "/// @details This file was generated automatically.  Do not edit it, for changes\n/// will be lost on next rebuild." ) \
        .replace( "<__DOXYGEN_AUTHOR_AND_EMAIL__>", "/// @author None (auto-generated by script code_templates/generate_library_api.py)." ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE_AND_NAME__>", namespace_and_source_class ) \
        .replace( "<__CPP_FWD_HEADER_GUARD__>", "#ifndef " + header_guard_string + "\n#define " + header_guard_string ) \
        .replace( "<__CPP_NAMESPACE__>", generate_cpp_namespace( namespace, True ) ) \
        .replace( "<__CPP_END_NAMESPACE__>", generate_cpp_namespace( namespace, False ) ) \
        .replace( "<__SOURCE_CLASS_API_NAME__>", apiclassname ) \
        .replace( "<__CPP_END_FWD_HEADER_GUARD__>", "#endif // " + header_guard_string )

    fname = dirname + apiclassname + ".fwd.hh"
    with open( fname, 'w' ) as filehandle :
        filehandle.write(fwdfile)
    print( "\tWrote \"" + fname + "\"."  )

## @brief Auto-generate the header file (***.hh) for the class.
def prepare_header_file( libraryname : str, classname : str, namespace : list, dirname : str, hhfile_template : str, licence : str, jsonfile : json, tabchar: str ) :
    apiclassname = classname + "_API"
    original_class_namespace_string = ""
    header_guard_string = "Masala_" + libraryname + "_api_auto_generated_api_"
    for i in range( len(namespace) ):
        original_class_namespace_string += namespace[i]
        if i+1<len(namespace) :
            original_class_namespace_string += "::"
        if i > 1 :
            header_guard_string += namespace[i] + "_"
    header_guard_string += apiclassname + "_hh"

    dirname_short = dirname.replace("src/", "")
    namespace_and_source_class = original_class_namespace_string + "::" + classname

    additional_includes = []

    hhfile = \
        hhfile_template \
        .replace( "<__COMMENTED_LICENCE__>", "/*\n" + licence + "\n*/\n" ) \
        .replace( "<__DOXYGEN_FILE_PATH_AND_HH_FILE_NAME__>", "/// @file " + dirname_short + apiclassname + ".hh" ) \
        .replace( "<__DOXYGEN_BRIEF_DESCRIPTION__>", "/// @brief Headers for auto-generated API for\n/// " + namespace_and_source_class + " class." ) \
        .replace( "<__DOXYGEN_DETAILED_DESCRIPTION__>", "/// @details This file was generated automatically.  Do not edit it, for changes\n/// will be lost on next rebuild." ) \
        .replace( "<__DOXYGEN_AUTHOR_AND_EMAIL__>", "/// @author None (auto-generated by script code_templates/generate_library_api.py)." ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE_AND_NAME__>", namespace_and_source_class ) \
        .replace( "<__SOURCE_CLASS_NAME__>", classname ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE__>", original_class_namespace_string ) \
        .replace( "<__CPP_HH_HEADER_GUARD__>", "#ifndef " + header_guard_string + "\n#define " + header_guard_string ) \
        .replace( "<__CPP_NAMESPACE__>", generate_cpp_namespace( namespace, True ) ) \
        .replace( "<__CPP_END_NAMESPACE__>", generate_cpp_namespace( namespace, False ) ) \
        .replace( "<__SOURCE_CLASS_API_NAME__>", apiclassname ) \
        .replace( "<__SOURCE_CLASS_API_NAMESPACE__>", generate_cpp_namespace_singleline( namespace ) ) \
        .replace( "<__INCLUDE_FILE_PATH_AND_FWD_FILE_NAME__>", "#include <" + dirname_short + apiclassname + ".fwd.hh>" ) \
        .replace( "<__INCLUDE_SOURCE_FILE_PATH_AND_FWD_FILE_NAME__>", "#include <" + generate_source_class_filename( classname, namespace, ".fwd.hh" ) + ">" ) \
        .replace( "<__INCLUDE_SOURCE_FILE_PATH_AND_HH_FILE_NAME__>", "#include <" + generate_source_class_filename( classname, namespace, ".hh" ) + ">" ) \
        .replace( "<__CPP_CONSTRUCTOR_PROTOTYPES__>", generate_constructor_prototypes(namespace_and_source_class, jsonfile, tabchar, additional_includes) ) \
        .replace( "<__CPP_SETTER_PROTOTYPES__>", generate_function_prototypes(namespace_and_source_class, jsonfile, tabchar, "SETTER", additional_includes) ) \
        .replace( "<__CPP_GETTER_PROTOTYPES__>", generate_function_prototypes(namespace_and_source_class, jsonfile, tabchar, "GETTER", additional_includes) ) \
        .replace( "<__CPP_WORK_FUNCTION_PROTOTYPES__>", generate_function_prototypes(namespace_and_source_class, jsonfile, tabchar, "WORKFXN", additional_includes) ) \
        .replace( "<__CPP_END_HH_HEADER_GUARD__>", "#endif // " + header_guard_string ) \
        .replace( "<__CPP_ADDITIONAL_FWD_INCLUDES__>", generate_additional_includes( additional_includes, True, dirname_short + apiclassname ) )

    fname = dirname + apiclassname + ".hh"
    with open( fname, 'w' ) as filehandle :
        filehandle.write(hhfile)
    print( "\tWrote \"" + fname + "\"."  )

## @brief Auto-generate the cc file (***.cc) for the class.
def prepare_cc_file( libraryname : str, classname : str, namespace : list, dirname : str, ccfile_template : str, licence : str, jsonfile : json, tabchar: str, is_lightweight: bool ) :
    apiclassname = classname + "_API"
    original_class_namespace_string = ""
    for i in range( len(namespace) ):
        original_class_namespace_string += namespace[i]
        if i+1<len(namespace) :
            original_class_namespace_string += "::"

    dirname_short = dirname.replace("src/", "")
    namespace_and_source_class = original_class_namespace_string + "::" + classname

    additional_includes = []

    ccfile = \
        ccfile_template \
        .replace( "<__COMMENTED_LICENCE__>", "/*\n" + licence + "\n*/\n" ) \
        .replace( "<__DOXYGEN_FILE_PATH_AND_CC_FILE_NAME__>", "/// @file " + dirname_short + apiclassname + ".cc" ) \
        .replace( "<__DOXYGEN_BRIEF_DESCRIPTION__>", "/// @brief Implementations for auto-generated API for\n/// " + namespace_and_source_class + " class." ) \
        .replace( "<__DOXYGEN_DETAILED_DESCRIPTION__>", "/// @details This file was generated automatically.  Do not edit it, for changes\n/// will be lost on next rebuild." ) \
        .replace( "<__DOXYGEN_AUTHOR_AND_EMAIL__>", "/// @author None (auto-generated by script code_templates/generate_library_api.py)." ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE_AND_NAME__>", namespace_and_source_class ) \
        .replace( "<__SOURCE_CLASS_NAME__>", classname ) \
        .replace( "<__SOURCE_CLASS_NAMESPACE__>", original_class_namespace_string ) \
        .replace( "<__CPP_NAMESPACE__>", generate_cpp_namespace( namespace, True ) ) \
        .replace( "<__CPP_END_NAMESPACE__>", generate_cpp_namespace( namespace, False ) ) \
        .replace( "<__SOURCE_CLASS_API_NAME__>", apiclassname ) \
        .replace( "<__SOURCE_CLASS_API_NAMESPACE__>", generate_cpp_namespace_singleline( namespace ) ) \
        .replace( "<__INCLUDE_FILE_PATH_AND_HH_FILE_NAME__>", "#include <" + dirname_short + apiclassname + ".hh>" ) \
        .replace( "<__INCLUDE_SOURCE_FILE_PATH_AND_HH_FILE_NAME__>", "#include <" + generate_source_class_filename( classname, namespace, ".hh" ) + ">" ) \
        .replace( "<__CPP_CONSTRUCTOR_IMPLEMENTATIONS__>", generate_constructor_implementations(namespace_and_source_class, jsonfile, tabchar, additional_includes) ) \
        .replace( "<__CPP_SETTER_IMPLEMENTATIONS__>", generate_function_implementations(namespace_and_source_class, jsonfile, tabchar, "SETTER", additional_includes, is_lightweight) ) \
        .replace( "<__CPP_GETTER_IMPLEMENTATIONS__>", generate_function_implementations(namespace_and_source_class, jsonfile, tabchar, "GETTER", additional_includes, is_lightweight) ) \
        .replace( "<__CPP_WORK_FUNCTION_IMPLEMENTATIONS__>", generate_function_implementations(namespace_and_source_class, jsonfile, tabchar, "WORKFXN", additional_includes, is_lightweight) ) \
        .replace( "<__CPP_ADDITIONAL_HH_INCLUDES__>", generate_additional_includes( additional_includes, False, dirname_short + apiclassname ) )

    fname = dirname + apiclassname + ".cc"
    with open( fname, 'w' ) as filehandle :
        filehandle.write(ccfile)
    print( "\tWrote \"" + fname + "\"."  )


################################################################################
## Program entry point
################################################################################

# Get options
library_name, api_def_file = get_options()
print( "\tGenerating API for library \"" + library_name + "\" from API definition file \"" + api_def_file + "\"." )

# Read JSON
with open( api_def_file, 'r' ) as jfile :
    json_api = json.load( jfile )

initialize_directory( library_name )
ccfile_template = read_file( "code_templates/api_templates/MasalaClassAPI.cc" )
hhfile_template = read_file( "code_templates/api_templates/MasalaClassAPI.hh" )
fwdfile_template = read_file( "code_templates/api_templates/MasalaClassAPI.fwd.hh" )

lightweight_ccfile_template = read_file( "code_templates/api_templates/MasalaLightWeightClassAPI.cc" )
lightweight_hhfile_template = read_file( "code_templates/api_templates/MasalaLightWeightClassAPI.hh" )
lightweight_fwdfile_template = read_file( "code_templates/api_templates/MasalaLightWeightClassAPI.fwd.hh" )

licence_template = read_file( "code_templates/licences/MIT.template" ).replace( "<__YEAR__>", str(2022) ).replace( "<__COPYRIGHT_HOLDER__>", "Vikram K. Mulligan" )
tabchar = "    "

for element in json_api["Elements"] :
    #print( element )
    namespace_string = json_api["Elements"][element]["ModuleNamespace"]
    name_string = json_api["Elements"][element]["Module"]
    namespace = separate_namespace( namespace_string )
    #print( namespace_string, name_string )
    #print( namespace )
    assert len(namespace) > 2
    assert namespace[0] == "masala", "Error!  All Masla classes (with or without APIs) are expected to be in base namespace \"masala\".  This doesn't seem to be so for " + namespace_string + "::" + name_string + "."
    assert namespace[1] == library_name, "Error!  All Masla classes in library " + library_name + " (with or without APIs) are expected to be in namespace \"masala::" + library_name + "\".  This doesn't seem to be so for " + namespace_string + "::" + name_string + "."
    dirname = prepare_directory( library_name, namespace )
    if json_api["Elements"][element]["Properties"]["Is_Lightweight"] == False :
        prepare_forward_declarations( library_name, name_string, namespace, dirname, fwdfile_template, licence_template )
        prepare_header_file( library_name, name_string, namespace, dirname, hhfile_template, licence_template, json_api, tabchar )
        prepare_cc_file( library_name, name_string, namespace, dirname, ccfile_template, licence_template, json_api, tabchar, False )
    else :
        prepare_forward_declarations( library_name, name_string, namespace, dirname, lightweight_fwdfile_template, licence_template )
        prepare_header_file( library_name, name_string, namespace, dirname, lightweight_hhfile_template, licence_template, json_api, tabchar )
        prepare_cc_file( library_name, name_string, namespace, dirname, lightweight_ccfile_template, licence_template, json_api, tabchar, True )

print( "\tFinished generating API for library \"" + library_name + "\" from API definition file \"" + api_def_file + "\"." )
    