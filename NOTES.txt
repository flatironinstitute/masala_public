- [X] Remove functions from API classes.
     - [X] On second thought, let's keep these around.
     - [X] Figure out problem of MasalaObjectAPIDefinition persisting after the object that it describes is destroyed.  Observer?  Hand out a weak pointer to a MasalaObjectAPIDefinition cached in the object?
          - [X] I'll hand out a weak pointer.
- [X] Do API classes need to be templated?  YES.
- [X] Add namespace function to all instantiable objects.
- [X] Add JSON functions.
     - [X] To MasalaObjectAPIDefinition.
     - [X] To MasalaObjectAPIConstructorDefinition and derived classes.
     - [X] To MasalaObjectAPISetterDefinition and derived classes.
     - [X] To MasalaObjectAPIGetterDefinition and derived classes.
     - [X] To MasalaObjectAPIWorkFunctionDefinition and derived classes.
- [X] Add app to generate API description from class list.
- [X] Add Python code to generate API layer from API descriptions.
- [X] Add script and compilation of API layer to build script.
     - [X] Auto-include classes that need to be included.
     - [X] Auto-use API classes instead of manually-written classes when API classes are available.

- [ ] Think about ElementType and where it should go.  Can this be moved to core?
- [ ] Add a full PDB reader in the standard plugin library.

- [ ] Use ViennaCL for linear algebra.
- [ ] Replace std::set with std::vector.

- [X] Add test for string-trimming functions.  Include edge case of strings with only whitespace.

- [X] Add list of API classes somewhere --> A manager where API classes get registered.
     - [ ] Ensure that plugin classes defined in core (e.g. AtomSelector) get registered.
- [ ] Get rid of the EigenLinalgCartesianAtomCoordinateRepresentationCreator class.  This should be auto-generated.

- [X] In auto-generated code, we need to handle the case of a function that returns a lightweight Masala object directly:
     - [X] Add "stack-allocated" option to API function.
     - [X] If stack-allocated, ensure that we initialize the API container by passing in the object by reference (not an owning pointer to a copy of the object) when making the API object to output.
- [X] Handle enums in API auto-generated code.
     - [X] Need to find additional fwd.hh file where the enum is declared for .hh file.
     - [X] Need to NOT include .hh file for enum types in .cc file.
     - [X] Need to fix output type namespace (NOT in auto-generated code) in both .cc and .hh file.
     - [X] Need to NOT encapsulate output type in API container in .cc file.
     - [X] Need to ensure that additional forward declarations are copied.

- [ ] Add explicit conversion functions for API classes whose inner objects are related by inheritence.
     - [ ] Re-enable the selectors' generate_selection() functions.
- [ ] Add API functions for CostFunctionNetworkOptimizationSolution.
- [ ] Add API functions for OptimizationProblem and OptimizationSolution.
     - [ ] Allow APIs for pure virtual classes.
     - [ ] Define class inheritence for APIs (see above).

- [ ] Abort compilation with informative error message if Z inherits from Y inherits from X, and X and Z have APIs defined but Y does not.  Or better yet, make the parent search recursive and inherit from the last API class.
- [ ] Use the code templates for the lightweight derived API classes.
- [X] Framework for on-the-fly CostFunctionNetworkProblems.
     - [X] Base class for CostFunctionNetworkProblem, that takes function pointer to a function for updating the cost function given a new selection.
     - [X] Derived class for PrecomputedPairwiseCostFunctionNetworkProblem.  The update function can ALSO be used, for non-pairwise terms.

- [ ] Add means of specifying parent class in API definition, and of optionally getting API definition that includes inherited functions.  (Need to think about how.)

- ~~Add a storage class for mutexes that ensure that they're not copied when the rest of an object is, so that we don't need to keep defining copy constructors and assignment operators.~~ This is a bad idea, unless I can do it with some sort of macros to ensure that mutexes get locked in copy constructors.  Otherwise, I need explicit copy constructors.
     - ~~Default the copy constructors and assignment operators that we have.~~

- [X] Ensure that optimers return a container of solutions by default, not just a single solution.
- [X] Ensure that optimers take a container of problems by default, not just a single problem.
	- [X] Derived CostFunctionNetworkOptimizationProblems class.
            - [X] Override add_optimization_problem() with type check.
	- [X] Derived PrecomputedPairwiseCostFunctionNetworkOptimizationProblems class.
            - [X] Override add_optimization_problem() with type check.
- [X] Optimizers need settings for repeats, threads to select.
     - [ ] Need settings for GPU.

- [ ] Add tests for PairwisePrecomputedCostFunctionNetworkOptimizationProblem.
     - [ ] In particular, need tests for move_twobody_energies_involving_one_choice_nodes_to_onebody_for_variable_nodes() functionality.

- [ ] Fix organization of Optimizer and CostFunctionNetworkOptimizer classes.  We need an abstract base class for their APIs that derived classes' APIs can inherit from...
- [ ] Same with AnnealingSchedule.
- [ ] Solution to the above:
     - [X] In the API descriptors, ensure that there's a way to indicate that a base class's API should have protected constructors, to prevent instantiation (like a pure virtual class).
          - [X] Update code templates.
          - [X] Update generate_library_api.py.
          - [X] Only add creators if the constructors are not protected.
     - [ ] Address the point above about making the API parent search recursive.
     - [ ] Add a simple way to add the constructor boilerplate (using macros) to the get_api_definition function.
     - [ ] Add a base class for AnnealingSchedule (AnnealingScheduleBase) in numeric.
          - [ ] Add a get_api_definition function to it.
          - [ ] Indicate that the API has a protected constructor.
     - [ ] Ensure that headers from numeric that are included in numeric_api get copied to the headers library (so that it's possible to inherit from numeric classes in plugin libraries).
          - [ ] Ensure that AnnealingSchedule class in numeric_api derives from numeric::*::AnnealingScheduleBase (so that we include the AnnealingScheduleBase.hh file from numeric in the header library).
     - [ ] In the standard Masala plugins library, have the MonteCarloCostFunctionNetworkOptimizer take an AnnealingScheduleBase_API object, not an AnnealingSchedule object.
     - [ ] In the standard Masala plugins library, have the ConstantAnnealingSchedule (and any other annealing schedules) derive from numeric_api::*::AnnealingSchedule.
     - [ ] Adjust Optimizer and CostFunctionNetworkOptimizer classes accordingly.
          - [ ] numeric_api::*::*Optimizer derives from numeric::*::OptimizerBase, which has a get_api_definition.
          - [ ] numeric_api::*::*CostFunctionNetworkOptimizer derives from numeric::*::CostFunctionNetworkOptimizerBase, which has a get_api_defintion (and which derives from OptimizerBase).
          - [ ] In numeric_api, add:
               - [ ] PluginOptimizationProblem, PluginOptimizationProblems
               - [ ] PluginOptimizationSolution, PluginOptimizationSolutions
               - [ ] PluginCostFunctionNetworkOptimizationProblem, PluginCostFunctionNetworkOptimizationProblems
               - [ ] PluginCostFunctionNetworkOptimizationSolution, PluginCostFunctionNetworkOptimizationSolutions
               - [ ] (Maybe?) PluginPairwisePrecomputedCostFunctionNetworkOptimizationProblem
               - [ ] (Maybe?) PluginPairwisePrecomputedCostFunctionNetworkOptimizationSolution
